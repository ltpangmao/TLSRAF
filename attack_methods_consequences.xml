<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<capec:Domain_Mappings xmlns:capec="http://capec.mitre.org/capec-2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" Catalog_Data="2014-06-23" Catalog_Name="CAPEC" Catalog_Version="2.6" xsi:schemaLocation="http://capec.mitre.org/capec-2 http://capec.mitre.org/data/xsd/ap_schema_v2.7.xsd  http://cybox.mitre.org/cybox-2 http://cybox.mitre.org/XMLSchema/core/2.1/cybox_core.xsd">
	<capec:Attack_Pattern id="332" name="ICMP IP 'ID' Field Error Message Probe">
		<capec:Attack_Pattern_Description>An attacker sends a UDP datagram having an assigned value to its internet identification field (ID) to a closed port on a target to observe the manner in which this bit is echoed back in the ICMP error message. The internet identification field (ID) is typically utilized for reassembling a fragmented packet. RFC791 and RFC815 discusses about IP datagrams, fragmentation and reassembly. Some operating systems or router firmware reverse the bit order of the ID field when echoing the IP Header portion of the original datagram within the ICMP error message. There are 3 behaviors that can be used to distinguish remote operating systems or firmware. The IP ID field is echoed back identically to the bit order of the ID field in the original IP header. The IP ID field is echoed back, but the byte order has been reversed. The IP ID field contains an incorrect or unexpected value. Different operating systems will respond by setting the IP ID field differently within error messaging. This allows the attacker to construct a fingerprint of specific OS behaviors.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send a UDP datagram to a closed port and receive an ICMP Error Message Type 3, "Port Unreachable.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="159" name="Redirect Access to Libraries">
		<capec:Attack_Pattern_Description>An attacker exploits the execution flow of a call to an external library to point to an attacker supplied library or code base, allowing the attacker to compromise the application or server via the execution of unauthorized code. An application typically makes calls to functions that are a part of libraries external to the application. These libraries may be part of the operating system or they may be third party libraries. If an attacker can redirect an application's attempts to access these libraries to other libraries that the attacker supplies, the attacker will be able to force the targeted application to execute arbitrary code. This is especially dangerous if the targeted application has enhanced privileges. Access can be redirected through a number of techniques, including the use of symbolic links, search path modification, and relative path manipulation.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target must utilize external libraries and must fail to verify the integrity of these libraries before using them.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Modification of Resources
			Injection
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="330" name="ICMP Error Message Echoing Integrity Probe">
		<capec:Attack_Pattern_Description>An attacker uses a technique to generate an ICMP Error message (Port Unreachable, Destination Unreachable, Redirect, Source Quench, Time Exceeded, Parameter Problem) from a target and then analyze the integrity of data returned or "Quoted" from the originating request that generated the error message. For this purpose "Port Unreachable" error messages are often used, as generating them requires the attacker to send a UDP datagram to a closed port on the target. When replying with an ICMP error message some IP/ICMP stack implementations change aspects of the IP header, change or reverse certain byte orders, reset certain field values to default values which differ between operating system and firmware implementations, and make other changes. Some IP/ICMP stacks are decidedly broken, indicating an idiosyncratic behavior that differs from the RFC specifications, such as the case when miscalculations affect a field value. A tremendous amount of information about the host operating system can be deduced from its 'echoing' characteristics. Notably, inspection of key protocol header fields, including the echoed header fields of the encapsulating protocol can yield a wealth of data about the host operating system or firmware version.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send a UDP datagram to a closed port and receive an ICMP Error Message Type 3, "Port Unreachable."
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="331" name="ICMP IP Total Length Field Probe">
		<capec:Attack_Pattern_Description>An attacker sends a UDP packet to a closed port on the target machine to solicit an IP Header's total length field value within the echoed 'Port Unreachable" error message. RFC1122 specifies that the Header of the request must be echoed back when an error is sent in response, but some operating systems and firmware alter the integrity of the original header. Non-standard ICMP/IP implementations result in response that are useful for individuating remote operating system or router firmware versions. There are four general response types that can be used to distinguish operating systems apart. 1. The IP total length field may be calculated correctly. 2. An operating system may add 20 or more additional bytes to the length calculation. 3. The operating system may subtract 20 or more bytes from the correct length of the field 4. The IP total length field is calculated with any other incorrect value. This type of behavior is useful for building a signature-base of operating system responses, particularly when error messages contain other types of information that is useful identifying specific operating system responses.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="205" name="Lifting credential(s)/key material embedded in client distributions (thick or thin)">
		<capec:Attack_Pattern_Description>An attacker examines a target application's code or configuration files to find credential or key material that has been embedded within the application or its files. Many services require authentication with their users for the various purposes including billing, access control or attribution. Some client applications store the user's authentication credentials or keys to accelerate the login process. Some clients may have built-in keys or credentials (in which case the server is authenticating with the client, rather than the user). If the attacker is able to locate where this information is stored, they may be able to retrieve these credentials. The attacker could then use these stolen credentials to impersonate the user or client, respectively, in interactions with the service or use stolen keys to eavesdrop on nominally secure communications between the client and server.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target application must save keys or credential information. Many applications allow users to store authentication information as an option.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="169" name="Footprinting">
		<capec:Attack_Pattern_Description>An attacker engages in probing and exploration activity to identify constituents and properties of the target. Footprinting is a general term to describe a variety of information gathering techniques, often used by attackers in preparation for some attack. It consists of using tools to learn as much as possible about the composition, configuration, and security mechanisms of the targeted application, system or network. Information that might be collected during a footprinting effort could include open ports, applications and their versions, network topology, and similar information. While footprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>None. Any system or network that can be detected can be footprinted. However, some configuration choices may limit the useful information that can be collected during a footprinting attack.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Injection
			Analysis
			Social Engineering
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="207" name="Removing Important Functionality from the Client">
		<capec:Attack_Pattern_Description>An attacker removes or disables functionality on the client that the server assumes to be present and trustworthy. Client applications may include functionality that a server relies on for correct and secure operation. This functionality can include, but is not limited to, filters to prevent the sending of dangerous content to the server, logical functionality such as price calculations, and authentication logic to ensure that only authorized users are utilizing the client. If an attacker can disable this functionality on the client, they can perform actions that the server believes are prohibited. This can result in client behavior that violates assumptions by the server leading to a variety of possible attacks. In the above examples, this could include the sending of dangerous content (such as scripts) to the server, incorrect price calculations, or unauthorized access to server resources.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The targeted server must assume the client performs important actions to protect the server or the server functionality. For example, the server may assume the client filters outbound traffic or that the client performs all price calculations correctly. Moreover, the server must fail to detect when these assumptions are violated by a client.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="540" name="Overread Buffers">
		<capec:Attack_Pattern_Description>An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>For this type of attack to be successful, a few prerequisites must be met. First, the targeted software must be written in a language that enables fine grained buffer control. (e.g., c, c++) Second, the targeted software must actually perform buffer operations and inadequately perform bounds-checking on those buffer operations. Finally, the adversary must have the capability to influence the input that guides these buffer operations.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="3" name="Using Leading 'Ghost' Character Sequences to Bypass Input Filters">
		<capec:Attack_Pattern_Description>An attacker intentionally introduces leading characters that enable getting the input past the filters. The API that is being targeted, ignores the leading "ghost" characters, and therefore processes the attackers' input. This occurs when the targeted API will accept input data in several syntactic forms and interpret it in the equivalent semantic way, while the filter does not take into account the full spectrum of the syntactic forms acceptable to the targeted API. Some APIs will strip certain leading characters from a string of parameters. Perhaps these characters are considered redundant, and for this reason they are removed. Another possibility is the parser logic at the beginning of analysis is specialized in some way that causes some characters to be removed. The attacker can specify multiple types of alternative encodings at the beginning of a string as a set of probes. One commonly used possibility involves adding ghost characters--extra characters that don't affect the validity of the request at the API layer. If the attacker has access to the API libraries being targeted, certain attack ideas can be tested directly in advance. Once alternative ghost encodings emerge through testing, the attacker can move from lab-based API testing to testing real-world service implementations.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The targeted API must ignore the leading ghost characters that are used to get past the filters for the semantics to be the same.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="2" name="Inducing Account Lockout">
		<capec:Attack_Pattern_Description>An attacker leverages the security functionality of the system aimed at thwarting potential attacks to launch a denial of service attack against a legitimate system user. Many systems, for instance, implement a password throttling mechanism that locks an account after a certain number of incorrect log in attempts. An attacker can leverage this throttling mechanism to lock a legitimate user out of their own account. The weakness that is being leveraged by an attacker is the very security feature that has been put in place to counteract attacks.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The system has a lockout mechanism.
			An attacker must be able to reproduce behavior that would result in an account being locked.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>API Abuse
			Flooding
			Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (other) 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="1" name="Accessing Functionality Not Properly Constrained by ACLs">
		<capec:Attack_Pattern_Description>In applications, particularly web applications, access to functionality is mitigated by the authorization framework, whose job it is to map ACLs to elements of the application's functionality; particularly URL's for web apps. In the case that the administrator failed to specify an ACL for a particular element, an attacker may be able to access it with impunity. An attacker with the ability to access functionality not properly constrained by ACLs can obtain sensitive information and possibly compromise the entire application. Such an attacker can access resources that must be available only to users at a higher privilege level, can access management sections of the application or can run queries for data that he is otherwise not supposed to.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The application must be navigable in a manner that associates elements (subsections) of the application with ACLs.
			The various resources, or individual URLs, must be somehow discoverable by the attacker
			The administrator must have forgotten to associate an ACL or has associated an inappropriately permissive ACL with a particular navigable resource.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="163" name="Spear Phishing">
		<capec:Attack_Pattern_Description>An attacker targets a specific user or group with a Phishing (CAPEC-98) attack tailored to a category of users in order to have maximum relevance and deceptive capability. Spear Phishing is an enhanced version of the Phishing attack targeted to a specific user or group. The quality of the targeted email is usually enhanced by appearing to come from a known or trusted entity. If the email account of some trusted entity has been compromised the message may be digitally signed. The message will contain information specific to the targeted users that will enhance the probability that they will follow the URL to the compromised site. For example, the message may indicate knowledge of the targets employment, residence, interests, or other information that suggests familiarity. As soon as the user follows the instructions in the message, the attack proceeds as a standard Phishing attack.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>None. Any user can be targeted by a Spear Phishing attack.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Social Engineering
			Spoofing
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="7" name="Blind SQL Injection">
		<capec:Attack_Pattern_Description>Blind SQL Injection results from an insufficient mitigation for SQL Injection. Although suppressing database error messages are considered best practice, the suppression alone is not sufficient to prevent SQL Injection. Blind SQL Injection is a form of SQL Injection that overcomes the lack of error messages. Without the error messages that facilitate SQL Injection, the attacker constructs input strings that probe the target through simple Boolean SQL expressions. The attacker can determine if the syntax and structure of the injection was successful based on whether the query was executed or not. Applied iteratively, the attacker determines how and where the target is vulnerable to SQL Injection. For example, an attacker may try entering something like "username' AND 1=1; --" in an input field. If the result is the same as when the attacker entered "username" in the field, then the attacker knows that the application is vulnerable to SQL Injection. The attacker can then ask yes/no questions from the database server to extract information from it. For example, the attacker can extract table names from a database using the following types of queries: If the above query executes properly, then the attacker knows that the first character in a table name in the database is a letter between m and z. If it doesn't, then the attacker knows that the character must be between a and l (assuming of course that table names only contain alphabetic characters). By performing a binary search on all character positions, the attacker can determine all table names in the database. Subsequently, the attacker may execute an actual attack and send something like:</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>SQL queries used by the application to store, retrieve or modify data.
			User-controllable input that is not properly validated by the application as part of SQL queries.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Analysis
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="6" name="Argument Injection">
		<capec:Attack_Pattern_Description>An attacker changes the behavior or state of a targeted application through injecting data or command syntax through the targets use of non-validated and non-filtered arguments of exposed services or methods.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Target software fails to strip all user-supplied input of any content that could cause the shell to perform unexpected actions.
			Software must allow for unvalidated or unfiltered input to be executed on operating system shell, and, optionally, the system configuration must allow for output to be sent back to client.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="5" name="Blue Boxing">
		<capec:Attack_Pattern_Description>This type of attack against older telephone switches and trunks has been around for decades. A tone is sent by an adversary to impersonate a supervisor signal which has the effect of rerouting or usurping command of the line. While the US infrastructure proper may not contain widespread vulnerabilities to this type of attack, many companies are connected globally through call centers and business process outsourcing. These international systems may be operated in countries which have not upgraded Telco infrastructure and so are vulnerable to Blue boxing. Blue boxing is a result of failure on the part of the system to enforce strong authorization for administrative functions. While the infrastructure is different than standard current applications like web applications, there are historical lessons to be learned to upgrade the access control for administrative functions.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>System must use weak authentication mechanisms for administrative functions.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (other) 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="4" name="Using Alternative IP Address Encodings">
		<capec:Attack_Pattern_Description>This attack relies on the attacker using unexpected formats for representing IP addresses. Networked applications may expect network location information in a specific format, such as fully qualified domains names, URL, IP address, or IP Address ranges. The issue that the attacker can exploit is that these design assumptions may not be validated against a variety of different possible encodings and network address location formats. Applications that use naming for creating policy namespaces for managing access control may be susceptible to being queried directly by IP addresses, which is ultimately a more generally authoritative way of communicating on a network. Alternative IP addresses can be used by the attacker to bypass application access control in order to gain access to data that is only protected by obscuring its location. In addition this type of attack can be used as a reconnaissance mechanism to provide entry point information that the attacker gathers to penetrate deeper into the system.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target software must fail to anticipate all of the possible valid encodings of an IP/web address.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="9" name="Buffer Overflow in Local Command-Line Utilities">
		<capec:Attack_Pattern_Description>This attack targets command-line utilities available in a number of shells. An attacker can leverage a vulnerability found in a command-line utility to escalate privilege to root.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target host exposes a command-line utility to the user.
			The command-line utility exposed by the target host has a buffer overflow vulnerability that can be exploited.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="8" name="Buffer Overflow in an API Call">
		<capec:Attack_Pattern_Description>This attack targets libraries or shared code modules which are vulnerable to buffer overflow attacks. An attacker who has access to an API may try to embed malicious code in the API function call and exploit a buffer overflow vulnerability in the function's implementation. All clients that make use of the code library thus become vulnerable by association. This has a very broad effect on security across a system, usually affecting more than one software process.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target host exposes an API to the user.
			One or more API functions exposed by the target host has a buffer overflow vulnerability.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>API Abuse
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="215" name="Fuzzing and observing application log data/errors for application mapping">
		<capec:Attack_Pattern_Description>An attacker sends random, malformed, or otherwise unexpected messages to a target application and observes the application's log or error messages returned. Fuzzing techniques involve sending random or malformed messages to a target and monitoring the target's response. The attacker does not initially know how a target will respond to individual messages but by attempting a large number of message variants they may find a variant that trigger's desired behavior. In this attack, the purpose of the fuzzing is to observe the application's log and error messages, although fuzzing a target can also sometimes cause the target to enter an unstable state, causing a crash. By observing logs and error messages, the attacker can learn details about the configuration of the target application and might be able to cause the target to disclose sensitive information.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target application must fail to sanitize incoming messages adequately before processing.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Injection
			Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="318" name="IP 'ID' Echoed Byte-Order Probe">
		<capec:Attack_Pattern_Description>This OS fingerprinting probe tests to determine if the remote host echoes back the IP 'ID' value from the probe packet. An attacker sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on the remote host to observe the manner in which this bit is echoed back in the ICMP error message. The identification field (ID) is typically utilized for reassembling a fragmented packet. Some operating systems or router firmware reverse the bit order of the ID field when echoing the IP Header portion of the original datagram within an ICMP error message.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="319" name="IP (DF) 'Don't Fragment Bit' Echoing Probe">
		<capec:Attack_Pattern_Description>This OS fingerprinting probe tests to determine if the remote host echoes back the IP 'DF' (Don't Fragment) bit in a response packet. An attacker sends a UDP datagram with the DF bit set to a closed port on the remote host to observe whether the 'DF' bit is set in the response packet. Some operating systems will echo the bit in the ICMP error message while others will zero out the bit in the response packet.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="213" name="Directory Traversal">
		<capec:Attack_Pattern_Description>An attacker with access to file system resources, either directly or via application logic, will use various file path specification or navigation mechanisms such as ".." in path strings and absolute paths to extend their range of access to inappropriate areas of the file system. The attacker attempts to either explore the file system for recon purposes or access directories and files that are intended to be restricted from their access. Exploring the file system can be achieved through constructing paths presented to directory listing programs, such as "ls" and 'dir', or through specially crafted programs that attempt to explore the file system. The attacker engaging in this type of activity is searching for information that can be used later in a more exploitive attack. Access to restricted directories or files can be achieved through modification of path references utilized by system applications.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target must leverage and access an underlying file system.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity Confidentiality Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="316" name="ICMP Fingerprinting Probes">
		<capec:Attack_Pattern_Description>An attacker engages in ICMP stack fingerprinting techniques to determine the operating system type and version of a remote target. The role of ICMP as an ubiquitous diagnostic messaging protocol means that ICMP fingerprinting techniques are applicable to almost any internet host in a similar manner as TCP. ICMP fingerprinting techniques involve the generation of ICMP messages and analyzing the responses. This method is limited in that most firewalls are configured to block ICMP messages for security reasons, so it is most effective when used on an internal network segment. OS fingerprints using ICMP usually involve multiple different probes as the information returned from any one probe is usually insufficient to support a reliable OS inference.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to generate and analyze ICMP messages from a target. In cases where certain message types are blocked by a firewall, the reliability of ICMP fingerprinting declines sharply.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="317" name="IP ID Sequencing Probe">
		<capec:Attack_Pattern_Description>This OS fingerprinting probe analyzes the IP 'ID' field sequence number generation algorithm of a remote host. Operating systems generate IP 'ID' numbers differently, allowing an attacker to identify the operating system of the host by examining how is assigns ID numbers when generating response packets. RFC 791 does not specify how ID numbers are chosen or their ranges, so ID sequence generation differs from implementation to implementation. There are two kinds of IP 'ID' sequence number analysis: 1. IP 'ID' Sequencing: Analyzing the IP 'ID' sequence generation algorithm for one protocol used by a host. 2. Shared IP 'ID' Sequencing: Analyzing the packet ordering via IP 'ID' values spanning multiple protocols, such as between ICMP and TCP.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="219" name="XML Routing Detour Attacks">
		<capec:Attack_Pattern_Description>An attacker subverts an intermediate system used to process XML content and forces the intermediate to modify and/or re-route the processing of the content. XML Routing Detour Attacks are Man in the Middle type attacks. The attacker compromises or inserts an intermediate system in the processing of the XML message. For example, WS-Routing can be used to specify a series of nodes or intermediaries through which content is passed. If any of the intermediate nodes in this route are compromised by an attacker they could be used for a routing detour attack. From the compromised system the attacker is able to route the XML process to other nodes of his or her choice and modify the responses so that the normal chain of processing is unaware of the interception. This system can forward the message to an outside entity and hide the forwarding and processing from the legitimate processing systems by altering the header information.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The targeted system must have multiple stages processing of XML content.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="314" name="IP Fingerprinting Probes">
		<capec:Attack_Pattern_Description>An attacker engages in IP-based techniques for the purpose of fingerprinting operating systems on the network. By interrogating a particular IP stack implementation with IP segments that deviate from the ordinary or expected rules of RFC 791, an attacker can construct a fingerprint of unique behaviors for the target operating system. When this set of behaviors is analyzed against a database of known fingerprints, an attacker can make reliable inferences about the operating system type and version.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send and receive TCP segments from a target in order to identify a particular TCP stack implementation.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="178" name="Cross-Site Flashing">
		<capec:Attack_Pattern_Description>An attacker is able to trick the victim into executing a Flash document that passes commands or calls to a Flash player browser plugin, allowing the attacker to exploit native Flash functionality in the client browser. This attack pattern occurs where an attacker can provide a crafted link to a Flash document (SWF file) which, when followed, will cause additional malicious instructions to be executed. The attacker does not need to serve or control the Flash document. The attack takes advantage of the fact that Flash files can reference external URLs. If variables that serve as URLs that the Flash application references can be controlled through parameters, then by creating a link that includes values for those parameters, an attacker can cause arbitrary content to be referenced and possibly executed by the targeted Flash application.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The targeted Flash application must reference external URLs and the locations thus referenced must be controllable through parameters. The Flash application must fail to sanitize such parameters against malicious manipulation. The victim must follow a crafted link created by the attacker.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="315" name="TCP/IP Fingerprinting Probes">
		<capec:Attack_Pattern_Description>An attacker engages in TCP stack fingerprinting techniques to determine the type and version of operating systems on the network. TCP Fingerprinting involves manipulating portions of the TCP header or other characteristics in order to elicit a unique and identifiable response from an operating system. This response is compared against a database of known operating system fingerprints and a guess about the operating system type and version is made.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send and receive TCP segments from a target in order to identify a particular TCP stack implementation.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="217" name="Exploiting Incorrectly Configured SSL Security Levels">
		<capec:Attack_Pattern_Description>An attacker may take advantage of a setting in SSL that allows for weaknesses within that setting to be exploited to gain access to data intended to be encrypted, or injection commands or other traffic into the encrypted stream to cause compromise of either the client or server.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Access to the client/server stream.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="312" name="Active OS Fingerprinting">
		<capec:Attack_Pattern_Description>An attacker engages in activity to detect the operating system or firmware version of a remote target by interrogating a device, server, or platform with a probe designed to solicit behavior that will reveal information about the operating systems or firmware in the environment. Operating System detection is possible because implementations of common protocols (Such as IP or TCP) differ in distinct ways. While the implementation differences are not sufficient to 'break' compatibility with the protocol the differences are detectable because the target will respond in unique ways to specific probing activity that breaks the semantic or logical rules of packet construction for a protocol. Different operating systems will have a unique response to the anomalous input, providing the basis to fingerprint the OS behavior. This type of OS fingerprinting can distinguish between operating system types and versions.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send and receive packets from a remote target, or the ability to passively monitor network communications.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="313" name="Passive OS Fingerprinting">
		<capec:Attack_Pattern_Description>An attacker engages in activity to detect the version or type of OS software in a an environment by passively monitoring communication between devices, nodes, or applications. Passive techniques for operating system detection send no actual probes to a target, but monitor network or client-server communication between nodes in order to identify operating systems based on observed behavior as compared to a database of known signatures or values. While passive OS fingerprinting is not usually as reliable as active methods it is more stealthy.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send and receive packets from a remote target, or the ability to passively monitor network communications.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="310" name="Scanning for Vulnerable Software">
		<capec:Attack_Pattern_Description>An attacker engages in scanning activity to find vulnerable software versions or types, such as operating system versions or network services. Vulnerable or exploitable network configurations, such as improperly firewalled systems, or misconfigured systems in the DMZ or external network, provide windows of opportunity for an attacker. Common types of vulnerable software include unpatched operating systems or services (e.g FTP, Telnet, SMTP, SNMP) running on open ports that the attacker has identified. Attackers usually begin probing for vulnerable software once the external network has been port scanned and potential targets have been revealed.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Access to the network on which the targeted system resides.
			Software tools used to probe systems over a range of ports and protocols.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="311" name="OS Fingerprinting">
		<capec:Attack_Pattern_Description>An adversary engages in fingerprinting activities to determine the type or version of the operating system of the remote target. Operating System detection is possible because implementations of common protocols (Such as IP or TCP) differ in distinct ways. While the implementation differences are not sufficient to 'break' compatibility with the protocol, the differences are detectable because the target will respond in unique ways to specific probing activity that breaks the semantic or logical rules of packet construction for a protocol. Different operating systems will have a unique response to anomalous input, providing the basis to fingerprint the OS behavior. This type of OS fingerprinting can distinguish between operating system types and versions. Fingerprinting remote operating systems involves taking an "active" or a "passive" approach. Active approaches to fingerprinting involve sending data packets that break the logical or semantic rules of a protocol and observing operating system response to artificial inputs. Passive approaches involve listening to the communication of one or more nodes and identifying the operating system or firmware of the devices involved based on the structure of their messages.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>None
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="170" name="Web Application Fingerprinting">
		<capec:Attack_Pattern_Description>An attacker sends a series of probes to a web application in order to elicit version-dependent and type-dependent behavior that assists in identifying the target. An attacker could learn information such as software versions, error pages, and response headers, variations in implementations of the HTTP protocol, directory structures, and other similar information about the targeted service. This information can then be used by an attacker to formulate a targeted attack plan. While web application fingerprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Any web application can be fingerprinted. However, some configuration choices can limit the useful information an attacker may collect during a fingerprinting attack.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="174" name="Flash Parameter Injection">
		<capec:Attack_Pattern_Description>An attacker injects values to global parameters into a Flash movie embedded in an HTML document. These injected parameters are controlled through arguments in the URL used to access the embedding HTML document. As such, this is a form of HTTP parameter injection, but the abilities granted to the Flash document (such as access to a page's document model, including associated cookies) make this attack more flexible. The injected parameters can allow the attacker to control other objects within the Flash movie as well as full control over the parent document's DOM model.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="222" name="iFrame Overlay">
		<capec:Attack_Pattern_Description>In an iFrame overlay attack the victim is tricked into unknowingly initiating some action in one system while interacting with the UI from seemingly completely different system. While being logged in to some target system, the victim visits the attackers' malicious site which displays a UI that the victim wishes to interact with. In reality, the iFrame overlay page has a transparent layer above the visible UI with action controls that the attacker wishes the victim to execute. The victim clicks on buttons or other UI elements they see on the page which actually triggers the action controls in the transparent overlaying layer. Depending on what that action control is, the attacker may have just tricked the victim into executing some potentially privileged (and most undesired) functionality in the target system to which the victim is authenticated. The basic problem here is that there is a dichotomy between what the victim thinks he or she is clicking on versus what he or she is actually clicking on.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The victim is communicating with the target application via a web based UI and not a thick client. The victim's browser security policies allow iFrames. The victim uses a modern browser that supports UI elements like clickable buttons (i.e. not using an old text only browser). The victim has an active session with the target system. The target system's interaction window is open in the victim's browser and supports the ability for initiating sensitive actions on behalf of the user in the target system.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Spoofing
			Social Engineering
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="327" name="TCP Options Probe">
		<capec:Attack_Pattern_Description>This OS fingerprinting probe analyzes the type and order of any TCP header options present within a response segment. Most operating systems use unique ordering and different option sets when options are present. RFC 793 does not specify a required order when options are present, so different implementations use unique ways of ordering or structuring TCP options. TCP options can be generated by ordinary TCP traffic.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="328" name="TCP 'RST' Flag Checksum Probe">
		<capec:Attack_Pattern_Description>This OS fingerprinting probe performs a checksum on any ASCII data contained within the data portion or a RST packet. Some operating systems will report a human-readable text message in the payload of a 'RST' (reset) packet when specific types of connection errors occur. RFC 1122 allows text payloads within reset packets but not all operating systems or routers implement this functionality.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="329" name="ICMP Error Message Quoting Probe">
		<capec:Attack_Pattern_Description>An attacker uses a technique to generate an ICMP Error message (Port Unreachable, Destination Unreachable, Redirect, Source Quench, Time Exceeded, Parameter Problem) from a target and then analyze the amount of data returned or "Quoted" from the originating request that generated the ICMP error message. For this purpose "Port Unreachable" error messages are often used, as generating them requires the attacker to send a UDP datagram to a closed port on the target. The goal of this analysis to make inferences about the type of operating system or firmware that sent the error message in reply. This is useful for identifying unique characteristics of operating systems because the RFC-1122 expected behavior reads: "Every ICMP error message includes the Internet header and at least the first 8 data octets of the datagram that triggered the error; more than 8 octets MAY be sent [...]." This contrasts with RFC-792 expected behavior, which limited the quoted text to 64 bits (8 octets). Given the latitude in the specification the resulting RFC-1122 stack implementations often respond with a high degree of variability in the amount of data quoted in the error message because "older" or "legacy" stacks may comply with the RFC-792 specification, while other stacks may choose a longer format in accordance with RFC-1122. As a general rule most operating systems or firmware will quote the first 8 bytes of the datagram triggering the error, but some IP stacks will quote more than the first 8 bytes of data.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send a UDP datagram to a closed port and receive an ICMP Error Message Type 3, "Port Unreachable"
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="323" name="TCP (ISN) Counter Rate Probe">
		<capec:Attack_Pattern_Description>This OS detection probe measures the average rate of initial sequence number increments during a period of time. Sequence numbers are incremented using a time-based algorithm and are susceptible to a timing analysis that can determine the number of increments per unit time. The result of this analysis is then compared against a database of operating systems and versions to determine likely operation system matches.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="324" name="TCP (ISN) Sequence Predictability Probe">
		<capec:Attack_Pattern_Description>This type of operating system probe attempts to determine an estimate for how predictable the sequence number generation algorithm is for a remote host. Statistical techniques, such as standard deviation, can be used to determine how predictable the sequence number generation is for a system. This result can then be compared to a database of operating system behaviors to determine a likely match for operating system and version.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="325" name="TCP Congestion Control Flag (ECN) Probe">
		<capec:Attack_Pattern_Description>This OS fingerprinting probe checks to see if the remote host supports explicit congestion notification (ECN) messaging. ECN messaging was designed to allow routers to notify a remote host when signal congestion problems are occurring. Explicit Congestion Notification messaging is defined by RFC 3168. Different operating systems and versions may or may not implement ECN notifications, or may respond uniquely to particular ECN flag types.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="326" name="TCP Initial Window Size Probe">
		<capec:Attack_Pattern_Description>This OS fingerprinting probe checks the initial TCP Window size. TCP stacks limit the range of sequence numbers allowable within a session to maintain the "connected" state within TCP protocol logic. The initial window size specifies a range of acceptable sequence numbers that will qualify as a response to an ACK packet within a session. Various operating systems use different Initial window sizes. The initial window size can be sampled by establishing an ordinary TCP connection.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="320" name="TCP Timestamp Probe">
		<capec:Attack_Pattern_Description>This OS fingerprinting probe examines the remote server's implementation of TCP timestamps. Not all operating systems implement timestamps within the TCP header, but when timestamps are used then this provides the attacker with a means to guess the operating system of the target. The attacker begins by probing any active TCP service in order to get response which contains a TCP timestamp. Different Operating systems update the timestamp value using different intervals. This type of analysis is most accurate when multiple timestamp responses are received and then analyzed. TCP timestamps can be found in the TCP Options field of the TCP header. 1. The attacker sends a probe packet to the remote host to identify if timestamps are present. 2. If the remote host is using timestamp, the attacker sends several requests and records the timestamp values. 3. The attacker analyzes the timestamp values and determines an average increments per second in the timestamps for the target. 3. The attacker compares this result to a database of known TCP timestamp increments for a possible match.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target OS must support the TCP timestamp option in order to obtain a fingerprint.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="321" name="TCP Sequence Number Probe">
		<capec:Attack_Pattern_Description>This OS fingerprinting probe tests the target system's assignment of TCP sequence numbers. One common way to test TCP Sequence Number generation is to send a probe packet to an open port on the target and then compare the how the Sequence Number generated by the target relates to the Acknowledgement Number in the probe packet. Different operating systems assign Sequence Numbers differently, so a fingerprint of the operating system can be obtained by categorizing the relationship between the acknowledgement number and sequence number as follows: 1. The Sequence Number generated by the target is Zero. 2. The Sequence Number generated by the target is the same as the acknowledgement number in the probe 3. The Sequence Number generated by the target is the acknowledgement number plus one 3. The Sequence Number is any other non-zero number.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send an TCP ACK segment to an open port and receive a response back containing a TCP sequence number.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="322" name="TCP (ISN) Greatest Common Divisor Probe">
		<capec:Attack_Pattern_Description>This OS fingerprinting probe sends a number of TCP SYN packets to an open port of a remote machine. The Initial Sequence Number (ISN) in each of the SYN/ACK response packets is analyzed to determine the smallest number that the target host uses when incrementing sequence numbers. This information can be useful for identifying an operating system because particular operating systems and versions increment sequence numbers using different values. The result of the analysis is then compared against a database of OS behaviors to determine the OS type and/or version.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="180" name="Exploiting Incorrectly Configured Access Control Security Levels">
		<capec:Attack_Pattern_Description>An attacker exploits a weakness in the configuration of access controls and is able to bypass the intended protection that these measures guard against and thereby obtain unauthorized access to the system or network. Sensitive functionality should always be protected with access controls. However configuring all but the most trivial access control systems can be very complicated and there are many opportunities for mistakes. If an attacker can learn of incorrectly configured access security settings, they may be able to exploit this in an attack. Most commonly, attackers would take advantage of controls that provided too little protection for sensitive activities in order to perform actions that should be denied to them. In some circumstances, an attacker may be able to take advantage of overly restrictive access control policies, initiating denial of services (if an application locks because it unexpectedly failed to be granted access) or causing other legitimate actions to fail due to security. The latter class of attacks, however, is usually less severe and easier to detect than attacks based on inadequate security restrictions. This attack pattern differs from CAPEC 1, "Accessing Functionality Not Properly Constrained by ACLs" in that the latter describes attacks where sensitive functionality lacks access controls, where, in this pattern, the access control is present, but incorrectly configured.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target must apply access controls, but incorrectly configure them. However, not all incorrect configurations can be exploited by an attacker. If the incorrect configuration applies too little security to some functionality, then the attacker may be able to exploit it if the access control would be the only thing preventing an attacker's access and it no longer does so. If the incorrect configuration applies too much security, it must prevent legitimate activity and the attacker must be able to force others to require this activity..
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart DoS: instability 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="182" name="Flash Injection">
		<capec:Attack_Pattern_Description>An attacker tricks a victim to execute malicious flash content that executes commands or makes flash calls specified by the attacker. One example of this attack is cross-site flashing, an attacker controlled parameter to a reference call loads from content specified by the attacker.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target must be capable of running Flash applications. In some cases, the victim must follow an attacker-supplied link.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="112" name="Brute Force">
		<capec:Attack_Pattern_Description>In this attack, some asset (information, functionality, identity, etc.) is protected by a finite secret value. The attacker attempts to gain access to this asset by using trial-and-error to exhaustively explore all the possible secret values in the hope of finding the secret (or a value that is functionally equivalent) that will unlock the asset. Examples of secrets can include, but are not limited to, passwords, encryption keys, database lookup keys, and initial values to one-way functions. The key factor in this attack is the attackers' ability to explore the possible secret space rapidly. This, in turn, is a function of the size of the secret space and the computational power the attacker is able to bring to bear on the problem. If the attacker has modest resources and the secret space is large, the challenge facing the attacker is intractable. While the defender cannot control the resources available to an attacker, they can control the size of the secret space. Creating a large secret space involves selecting one's secret from as large a field of equally likely alternative secrets as possible and ensuring that an attacker is unable to reduce the size of this field using available clues or cryptanalysis. Doing this is more difficult than it sounds since elimination of patterns (which, in turn, would provide an attacker clues that would help them reduce the space of potential secrets) is difficult to do using deterministic machines, such as computers. Assuming a finite secret space, a brute force attack will eventually succeed. The defender must rely on making sure that the time and resources necessary to do so will exceed the value of the information. For example, a secret space that will likely take hundreds of years to explore is likely safe from raw-brute force attacks.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker must be able to determine when they have successfully guessed the secret. As such, one-time pads are immune to this type of attack since there is no way to determine when a guess is correct.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="110" name="SQL Injection through SOAP Parameter Tampering">
		<capec:Attack_Pattern_Description>An attacker modifies the parameters of the SOAP message that is sent from the service consumer to the service provider to initiate a SQL injection attack. On the service provider side, the SOAP message is parsed and parameters are not properly validated before being used to access a database in a way that does not use parameter binding, thus enabling the attacker to control the structure of the executed SQL query. This pattern describes a SQL injection attack with the delivery mechanism being a SOAP message.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>SOAP messages are used as a communication mechanism in the system
			SOAP parameters are not properly validated at the service provider
			The service provider does not properly utilize parameter binding when building SQL queries
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Analysis
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Availability 
			Impact(Motivation):  Unexpected State 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="111" name="JSON Hijacking (aka JavaScript Hijacking)">
		<capec:Attack_Pattern_Description>An attacker targets a system that uses JavaScript Object Notation (JSON) as a transport mechanism between the client and the server (common in Web 2.0 systems using AJAX) to steal possibly confidential information transmitted from the server back to the client inside the JSON object by taking advantage of the loophole in the browser's Same Origin Policy that does not prohibit JavaScript from one website to be included and executed in the context of another website. An attacker gets the victim to visit his or her malicious page that contains a script tag whose source points to the vulnerable system with a URL that requests a response from the server containing a JSON object with possibly confidential information. The malicious page also contains malicious code to capture the JSON object returned by the server before any other processing on it can take place, typically by overriding the JavaScript function used to create new objects. This hook allows the malicious code to get access to the creation of each object and transmit the possibly sensitive contents of the captured JSON object to the attackers' server. There is nothing in the browser's security model to prevent the attackers' malicious JavaScript code (originating from attacker's domain) to set up an environment (as described above) to intercept a JSON object response (coming from the vulnerable target system's domain), read its contents and transmit to the attackers' controlled site. The same origin policy protects the domain object model (DOM), but not the JSON.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>JSON is used as a transport mechanism between the client and the server
			The target server cannot differentiate real requests from forged requests
			The JSON object returned from the server can be accessed by the attackers' malicious code via a script tag
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Analysis
			Spoofing
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="127" name="Directory Indexing">
		<capec:Attack_Pattern_Description>An adversary crafts a request to a target that results in the target listing/indexing the content of a directory as output. One common method of triggering directory contents as output is to construct a request containing a path that terminates in a directory name rather than a file name since many applications are configured to provide a list of the directory's contents when such a request is received. An adversary can use this to explore the directory tree on a target as well as learn the names of files. This can often end up revealing test files, backup files, temporary files, hidden files, configuration files, user accounts, script contents, as well as naming conventions, all of which can be used by an attacker to mount additional attacks.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target must be misconfigured to return a list of a directory's content when it receives a request that ends in a directory name rather than a file name.
			The adversary must be able to control the path that is requested of the target.
			The administrator must have failed to properly configure an ACL or has associated an overly permissive ACL with a particular directory.
			The server version or patch level must not inherently prevent known directory listing attacks from working.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Brute Force
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="300" name="Port Scanning">
		<capec:Attack_Pattern_Description>An attacker uses a combination of techniques to determine the state of the ports on a remote target. Any service or application available for TCP or UDP networking will have a port open for communications over the network. Although common services have assigned port numbers, services and applications can run on arbitrary ports. Additionally, port scanning is complicated by the potential for any machine to have up to 65535 possible UDP or TCP services. The goal of port scanning is often broader than identifying open ports, but also give the attacker information concerning the firewall configuration. Depending upon the method of scanning that is used, the process can be stealthy or more obtrusive, the latter being more easily detectable due to the volume of packets involved, anomalous packet traits, or system logging. Typical port scanning activity involves sending probes to a range of ports and observing the responses. There are four types of port status that a port scan usually attempts to discover: 1. Open Port: The port is open and a firewall does not block access to the port 2. Closed Port: The port is closed (i.e. no service resides there) and a firewall does not block access to the port 3. Filtered Port: A firewall or ACL rule is blocking access to the port in some manner, although the presence of a listening service on the port cannot be verified 4. Unfiltered Port: A firewall or ACL rule is not blocking access to the port, although the presence of a listening service on the port cannot be verified. For strategic purposes it is useful for an attacker to distinguish between an open port that is protected by a filter vs. a closed port that is not protected by a filter. Making these fine grained distinctions is impossible with certain scan types. A TCP connect scan, for instance, cannot distinguish a blocked port with an active service from a closed port that is not firewalled. Other scan types can only detect closed ports, while others cannot detect port state at all, only the presence or absence of filters. Collecting this type of information tells the attacker which ports can be attacked directly, which must be attacked with filter evasion techniques like fragmentation, source port scans, and which ports are unprotected (i.e. not firewalled) but aren't hosting a network service. An attacker often combines various techniques in order to gain a more complete picture of the firewall filtering mechanisms in place for a host.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="302" name="TCP FIN scan">
		<capec:Attack_Pattern_Description>An attacker uses a TCP FIN scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with the FIN bit set in the packet header. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. The major advantage of this scan type is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to 'build' a connection. FIN packets, like out-of-state ACK packets, tend to pass through such devices undetected. Many operating systems, however, do not implement RFC 793 exactly and for this reason FIN scans do not work as expected against these devices. Some operating systems, like Microsoft Windows, send a RST packet in response to any out-of-sync (or malformed) TCP segments received by a listening socket (rather than dropping the packet via RFC 793), thus preventing an attacker from distinguishing between open and closed ports. 1. Speed: TCP FIN scanning is fast compared to other types of scans 2. Stealth: TCP FIN scanning is stealthy compared to other types of scans 3. Open Port: Detects an open port via no response to the segment 4. Closed Port: Detects that a closed via a RST received in response to the FIN 5. Filtered Port: Cannot distinguish between a filtered port and an open port 6. Unfiltered Port: Cannot distinguish between an unfiltered port and a non-stateful filtered port FIN scans are limited by the range of platforms against which they work. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, FIN scanning a system protected by a stateful firewall may indicate all ports being open. For these reasons, FIN scanning results must always be interpreted as part of a larger scanning strategy. FIN scanning is still relatively stealthy as the packets tend to blend in with the background noise on a network link. FIN scans are detected via heuristic (non-signature) based algorithms, much in the same way as other scan types are detected.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>FIN scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="301" name="TCP Connect Scan">
		<capec:Attack_Pattern_Description>An attacker uses full TCP connection attempts to determine if a port is open. The scanning process involves completing a 'three-way handshake' with a remote port, and reports the port as closed if the full handshake cannot be established. An advantage of TCP connect scanning is that it works against any TCP/IP stack. RFC 793 defines how TCP connections are established and torn down. TCP connect scanning commonly involves establishing a full connection, and then subsequently tearing it down, and therefore involves sending a significant number of packets to each port that is scanned. This type of scanning has the following characteristics. Compared to other types of scans, a TCP Connect scan is slow and methodical. This type of scanning causes considerable noise in system logs and can be spotted by IDS/IPS systems. In terms of port status, TCP Connect scanning can detect when a port is open by completing the three-way handshake, but it cannot distinguish a port that is unfiltered with no service running on it from a port that is filtered by a firewall but contains an active service. Due to the significant volume of packets exchanged per port, TCP connect scanning can become very time consuming. Generally, it is not used as a method for performing a comprehensive port scan, but is reserved for checking a short list of common ports. A TCP Connect scan has the following characteristics: 1. Speed: TCP Connect scanning is very slow. 2. Stealth: TCP SYN scanning is extremely noisy and involves a significant number of packets. 3. Open Port: Detects that a port is open via a successful three-way handshake 4. Filtered Port: Cannot distinguish a closed (unfiltered) port from an open (filtered) port. 5 .Unfiltered Port: Can detect an unfiltered port only when the unfiltered port is in front of an active TCP/IP service. The TCP Connect scan has the advantage of versatility and ease of use in that it works equally well against all TCP stacks and that it is easy for a novice to interpret the results of the scan due to its all or nothing nature. Its disadvantages are noise, speed, and poor visibility into the filter structure of a firewall. As a general rule, performing a full TCP connect scan against a host can take multiple days.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The TCP connect requires the ability to connect to an available port and complete a 'three-way-handshake' This scanning technique does not require any special privileges in order to perform. This type of scan works against all TCP/IP stack implementations.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="304" name="TCP Null Scan">
		<capec:Attack_Pattern_Description>An attacker uses a TCP NULL scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with no flags in the packet header, generating packets that are illegal based on RFC 793. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. he major advantage of this scan type is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to 'build' a connection. NULL packets, like out-of-state FIN or ACK packets, tend to pass through such devices undetected. Many operating systems, however, do not implement RFC 793 exactly and for this reason NULL scans do not work as expected against these devices. Some operating systems, like Microsoft Windows, send a RST packet in response to any out-of-sync (or malformed) TCP segments received by a listening socket (rather than dropping the packet via RFC 793), thus preventing an attacker from distinguishing between open and closed ports. 1. Speed: TCP NULL scanning is fast compared to other types of scans 2. Stealth: TCP NULL scanning was once stealthy, but is now easily detected by IDS/IPS systems 3. Open Port: Detects an open port via no response to the segment 4. Closed Port: Detects that a closed via a RST received in response to the FIN 5. Filtered Port: Cannot distinguish between a filtered port and an open port 6. Unfiltered Port: Cannot distinguish between an unfiltered port and a non-stateful filtered port NULL scans are limited by the range of platforms against which they work. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, NULL scanning a system protected by a stateful firewall may indicate all ports being open. Because of their obvious rule-breaking nature, NULL scans are flagged by almost all intrusion prevention or intrusion detection systems.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>NULL scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="303" name="TCP Xmas Scan">
		<capec:Attack_Pattern_Description>An attacker uses a TCP XMAS scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with the all flags sent in the packet header, generating packets that are illegal based on RFC 793. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. he major advantage of this scan type is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to 'build' a connection. XMAS packets, like out-of-state FIN or ACK packets, tend to pass through such devices undetected. Many operating systems, however, do not implement RFC 793 exactly and for this reason FIN scans do not work as expected against these devices. Some operating systems, like Microsoft Windows, send a RST packet in response to any out-of-sync (or malformed) TCP segments received by a listening socket (rather than dropping the packet via RFC 793), thus preventing an attacker from distinguishing between open and closed ports. 1. Speed: TCP XMAS scanning is fast compared to other types of scans 2. Stealth: TCP XMAS scanning was once stealthy, but is now easily detected by IDS/IPS systems 3. Open Port: Detects an open port via no response to the segment 4. Closed Port: Detects that a closed via a RST received in response to the FIN 5. Filtered Port: Cannot distinguish between a filtered port and an open port 6. Unfiltered Port: Cannot distinguish between an unfiltered port and a non-stateful filtered port XMAS scans are limited by the range of platforms against which they work. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, XMAS scanning a system protected by a stateful firewall may indicate all ports being open. Because of their obvious rule-breaking nature, XMAS scans are flagged by almost all intrusion prevention or intrusion detection systems.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>XMAS scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
			Scope:  Availability 
			Impact(Motivation):  Unexpected State 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="306" name="TCP Window Scan">
		<capec:Attack_Pattern_Description>An attacker engages in TCP Window scanning to analyze port status and operating system type. TCP Window scanning uses the ACK scanning method but examine the TCP Window Size field of response RST packets to make certain inferences. This scanning method works against fewer TCP stack implementations than any other type of scan. Some operating systems return a positive TCP window size when a RST packet is sent from an open port, and a negative value when the RST originates from a closed port. 1. Speed: TCP Window scanning is fast compared to other types of scans 2. Stealth: TCP Window scanning is relatively stealthy, much like ACK scanning 3. Open Port: Can detect open ports based on Window size for a limited number of operating systems 4. Closed Port: Can detect closed ports based on Window size for limited number of operating systems 5. Filtered Port: Can identify filtered ports when combined with other methods 6. Unfiltered Port: Can identify unfiltered ports when combined with other methods TCP Window scanning is one of the most complex scan types, and its results are difficult to interpret. Window scanning alone rarely yields useful information, but when combined with other types of scanning is more useful. TCP Window scanning is a more reliable means of making inference about operating system versions than port status.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>TCP Window scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="305" name="TCP ACK Scan">
		<capec:Attack_Pattern_Description>An attacker uses TCP ACK segments to gather information about firewall or ACL configuration. The purpose of this type of scan is to discover information about filter configurations rather than port state. This type of scanning is rarely useful alone, but when combined with SYN scanning, gives a more complete picture of the type of firewall rules that are present. When a TCP ACK segment is sent to a closed port, or sent out-of-sync to a listening port, the RFC 793 expected behavior is for the device to respond with a RST. Getting RSTs back in response to a ACK scan gives the attacker useful information that can be used to infer the type of firewall present. Stateful firewalls will discard out-of-sync ACK packets, leading to no response. When this occurs the port is marked as filtered. When RSTs are received in response, the ports are marked as unfiltered, as the ACK packets solicited the expected behavior from a port. When combined with SYN techniques an attacker can gain a more complete picture of which types of packets get through to a host and thereby map out its firewall rule-set. ACK scanning, when combined with SYN scanning, also allows the attacker analyze whether a firewall is stateful or non-stateful. If a SYN solicits a SYN/ACK or a RST and an ACK solicits a RST, the port is unfiltered by any firewall type. If a SYN solicits a SYN/ACK, but an ACK generates no response, the port is statefully filtered. When a SYN generates neither a SYN/ACK or a RST, but an ACK generates a RST, the port is statefully filtered. When neither SYN nor ACK generates any response, the port is blocked by a specific firewall rule, which can occur via any type of firewall. 1. Speed: TCP ACK scanning is fast compared to other types of scans 2. Stealth: TCP ACK scanning is stealthy 3. Open Port: Cannot detect open ports 4. Closed Port: Cannot detect closed ports 5. Filtered Port: Can detect stateful vs. non-stateful filters when combined with SYN probes 6. Unfiltered Port: Can detect unfiltered ports when combined with SYN probes Interpreting the results of ACK scanning requires rather sophisticated analysis. A skilled attacker may use this method to map out firewall rules, but the results of ACK scanning will be less useful to a novice.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>ACK scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="308" name="UDP Scan">
		<capec:Attack_Pattern_Description>An attacker engages in UDP scanning to gather information about UDP port status. UDP scanning methods involve sending a UDP datagram to the target port and looking for evidence that the port is closed. Open UDP ports usually do not respond to UDP datagrams as there is no stateful mechanism within the protocol that requires building or establishing a session. Responses to UDP datagrams are therefore application specific and cannot be relied upon as a method of detecting an open port. UDP scanning relies heavily upon ICMP diagnostic messages in order to determine the status of a remote port. Firewalls or ACLs which block egress ICMP error types effectively prevent UDP scans from returning any useful information. UDP scanning is further complicated by rate limiting mechanisms governing ICMP error messages. During a UDP scan, a datagram is sent to a target port. If an ICMP Type 3 Port unreachable error message is returned then the port is considered closed. Different types of ICMP messages can indicate a filtered port. 1. Speed: UDP scanning is very slow due to ICMP rate limiting 2. Stealth: RPC scanning is relatively stealthy provided the sending rate does not trigger IPS/IDS sensors 3. Open Port: Infers an open port based on no response, or an occasional response by a well-known service 4. Closed Port: Detects a closed port using return ICMP diagnostic messages from the host 5. Filtered Port: Can detect some filtered ports via ICMP diagnostic messages 6. Unfiltered Port: Can detect unfiltered ports based on some ICMP diagnostic messages The protocol characteristics of UDP make port scanning inherently more difficult than with TCP, as well as dependent upon ICMP for accurate scanning. Due to ambiguities that can arise between open ports and filtered ports, UDP scanning results often require a high degree of interpretation and further testing to refine. In general, UDP scanning results are less reliable or accurate than TCP-based scanning.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send UDP datagrams to a host and receive ICMP error messages from that host. In cases where particular types of ICMP messaging is disallowed, the reliability of UDP scanning drops off sharply.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="307" name="TCP RPC Scan">
		<capec:Attack_Pattern_Description>An attacker scan for RPC services listing on a Unix/Linux host. This type of scan can be obtained via native operating system utilities or via port scanners like nmap. When performed by a scanner, an RPC datagram is sent to a list of UDP ports and the response is recorded. Particular types of responses can be indicative of well-known RPC services running on a UDP port. 1. Speed: Direct RPC scans that bypass portmapper/sunrpc are typically slow compare to other scan types 2. Stealth: RPC scanning is not stealthy, as IPS/IDS systems detect RPC queries 3. Open Port: Can only detect open ports when an RPC service responds 4. Closed Port: Detects closed ports on the basis of ICMP diagnostic messages. 5. Filtered Port: Cannot identify filtered ports 6. Unfiltered Port: Cannot identify unfiltered ports There are two general approaches to RPC scanning. One is to use a native operating system utility, or script, to query the portmapper/rpcbind application running on port 111. Portmapper will return a list of registered RPC services. Alternately, one can use a port scanner or script to scan for RPC services directly. Discovering RPC services gives the attacker potential targets to attack, as some RPC services are insecure by default.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>RPC scanning requires no special privileges when it is performed via a native system utility.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="309" name="Network Topology Mapping">
		<capec:Attack_Pattern_Description>An adversary engages in scanning activities to map network nodes, hosts, devices, and routes. Adversaries usually perform this type of network reconnaissance during the early stages of attack against an external network. Many types of scanning utilities are typically employed, including ICMP tools, network mappers, port scanners, and route testing utilities such as traceroute.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>None
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="135" name="Format String Injection">
		<capec:Attack_Pattern_Description>An attacker includes formatting characters in a string input field on the target application. Most applications assume that users will provide static text and may respond unpredictably to the presence of formatting character. For example, in certain functions of the C programming languages such as printf, the formatting character %s will print the contents of a memory location expecting this location to identify a string and the formatting character %n prints the number of DWORD written in the memory. An attacker can use this to read or write to memory locations or files, or simply to manipulate the value of the resulting text in unexpected ways. Reading or writing memory may result in program crashes and writing memory could result in the execution of arbitrary code if the attacker can write to the program stack.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target application must accept a strings as user input, fail to sanitize string formatting characters in the user input, and process this string using functions that interpret string formatting characters.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:   
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:   
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:   
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="132" name="Symlink Attack">
		<capec:Attack_Pattern_Description>An attacker positions a symbolic link in such a manner that the targeted user or application accesses the link's endpoint, assuming that it is accessing a file with the link's name. The endpoint file may be either output or input. If the file is output, the result is that the endpoint is modified, instead of a file at the intended location. Modifications to the endpoint file may include appending, overwriting, corrupting, changing permissions, or other modifications. In some variants of this attack the attacker may be able to control the change to a file while in other cases they cannot. The former is especially damaging since the attacker may be able to grant themselves increased privileges or insert false information, but the latter can also be damaging as it can expose sensitive information or corrupt or destroy vital system or application files. Alternatively, the endpoint file may serve as input to the targeted application. This can be used to feed malformed input into the target or to cause the target to process different information, possibly allowing the attacker to control the actions of the target or to cause the target to expose information to the attacker. Moreover, the actions taken on the endpoint file are undertaken with the permissions of the targeted user or application, which may exceed the permissions that the attacker would normally have.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The targeted application must perform the desired activities on a file without checking whether the file is a symbolic link or not. The attacker must be able to predict the name of the file the target application is modifying and be able to create a new symbolic link where that file would appear.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Spoofing
			Analysis
			Time and State
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart DoS: instability 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="139" name="Relative Path Traversal">
		<capec:Attack_Pattern_Description>An attacker exploits a weakness in input validation on the target by supplying a specially constructed path utilizing dot and slash characters for the purpose of obtaining access to arbitrary files or resources. An attacker modifies a known path on the target in order to reach material that is not available through intended channels. These attacks normally involve adding additional path separators (/ or \) and/or dots (.), or encodings thereof, in various combinations in order to reach parent directories or entirely separate trees of the target's directory structure.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target application must accept a string as user input, fail to sanitize combinations of characters in the input that have a special meaning in the context of path navigation, and insert the user-supplied string into path navigation commands.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:   
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:   
			Impact(Motivation):  Bypass protection mechanism 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
			Scope:  Availability 
			Impact(Motivation):  DoS: instability 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="136" name="LDAP Injection">
		<capec:Attack_Pattern_Description>An attacker manipulates or crafts an LDAP query for the purpose of undermining the security of the target. Some applications use user input to create LDAP queries that are processed by an LDAP server. For example, a user might provide their username during authentication and the username might be inserted in an LDAP query during the authentication process. An attacker could use this input to inject additional commands into an LDAP query that could disclose sensitive information. For example, entering a * in the aforementioned query might return information about all users on the system. This attack is very similar to an SQL injection attack in that it manipulates a query to gather additional information or coerce a particular return value.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target application must accept a string as user input, fail to sanitize characters that have a special meaning in LDAP queries in the user input, and insert the user-supplied string in an LDAP query which is then processed.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
			Scope:  Availability 
			Impact(Motivation):  DoS: instability 
			Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="147" name="XML Ping of the Death">
		<capec:Attack_Pattern_Description>An attacker initiates a resource depletion attack where a large number of small XML messages are delivered at a sufficiently rapid rate to cause a denial of service or crash of the target. Transactions such as repetitive SOAP transactions can deplete resources faster than a simple flooding attack because of the additional resources used by the SOAP protocol and the resources necessary to process SOAP messages. The transactions used are immaterial as long as they cause resource utilization on the target. In other words, this is a normal flooding attack augmented by using messages that will require extra processing on the target.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target must receive and process XML transactions.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Flooding
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (other) 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="142" name="DNS Cache Poisoning">
		<capec:Attack_Pattern_Description>A domain name server translates a domain name (such as www.example.com) into an IP address that Internet hosts use to contact Internet resources. An attacker modifies a public DNS cache to cause certain names to resolve to incorrect addresses that the attacker specifies. The result is that client applications that rely upon the targeted cache for domain name resolution will be directed not to the actual address of the specified domain name but to some other address. Attackers can use this to herd clients to sites that install malware on the victim's computer or to masquerade as part of a Pharming attack.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>A DNS cache must be vulnerable to some attack that allows the attacker to replace addresses in its lookup table.
			Client applications must trust the corrupted cashed values and utilize them for their domain name resolutions.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence> empty 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="141" name="Cache Poisoning">
		<capec:Attack_Pattern_Description>An attacker exploits the functionality of cache technologies to cause specific data to be cached that aids the attackers' objectives. This describes any attack whereby an attacker places incorrect or harmful material in cache. The targeted cache can be an application's cache (e.g. a web browser cache) or a public cache (e.g. a DNS or ARP cache). Until the cache is refreshed, most applications or clients will treat the corrupted cache value as valid. This can lead to a wide range of exploits including redirecting web browsers towards sites that install malware and repeatedly incorrect calculations based on the incorrect value.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker must be able to modify the value stored in a cache to match a desired value.
			The targeted application must not be able to detect the illicit modification of the cache and must trust the cache value in its calculations.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence> empty 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="197" name="XML Entity Expansion">
		<capec:Attack_Pattern_Description>An attacker submits an XML document to a target application where the XML document uses nested entity expansion to produce an excessively large output XML. XML allows the definition of macro-like structures that can be used to simplify the creation of complex structures. However, this capability can be abused to create excessive demands on a processor's CPU and memory. A small number of nested expansions can result in an exponential growth in demands on memory.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>This type of attack requires that the target must receive XML input but either fail to provide an upper limit for entity expansion or provide a limit that is so large that it does not preclude significant resource consumption.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Flooding
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: amplification DoS: resource consumption (CPU) DoS: resource consumption (memory) DoS: resource consumption (other) 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="196" name="Session Credential Falsification through Forging">
		<capec:Attack_Pattern_Description>An attacker creates a false but functional session credential in order to gain or usurp access to a service. Session credentials allow users to identify themselves to a service after an initial authentication without needing to resend the authentication information (usually a username and password) with every message. If an attacker is able to forge valid session credentials they may be able to bypass authentication or piggy-back off some other authenticated user's session. This attack differs from Reuse of Session IDs and Session Sidejacking attacks in that in the latter attacks an attacker uses a previous or existing credential without modification while, in a forging attack, the attacker must create their own credential, although it may be based on previously observed credentials.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The targeted application must use session credentials to identify legitimate users. Session identifiers that remains unchanged when the privilege levels change. Predictable session identifiers.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Time and State
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="193" name="PHP Remote File Inclusion">
		<capec:Attack_Pattern_Description>In this pattern the attacker is able to load and execute arbitrary code remotely available from the application. This is usually accomplished through an insecurely configured PHP runtime environment and an improperly sanitized "include" or "require" call, which the user can then control to point to any web-accessible file. This allows attackers to hijack the targeted application and force it to execute their own instructions.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Target application server must allow remote files to be included in the "require", "include", etc. PHP directives
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="199" name="Cross-Site Scripting Using Alternate Syntax">
		<capec:Attack_Pattern_Description>The attacker uses alternate forms of keywords or commands that result in the same action as the primary form but which may not be caught by filters. For example, many keywords are processed in a case insensitive manner. If the site's web filtering algorithm does not convert all tags into a consistent case before the comparison with forbidden keywords it is possible to bypass filters (e.g., incomplete black lists) by using an alternate case structure. For example, the "script" tag using the alternate forms of "Script" or "ScRiPt" may bypass filters where "script" is the only form tested. Other variants using different syntax representations are also possible as well as using pollution meta-characters or entities that are eventually ignored by the rendering engine. The attack can result in the execution of otherwise prohibited functionality.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Target client software must allow scripting such as JavaScript.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="35" name="Leverage Executable Code in Non-Executable Files">
		<capec:Attack_Pattern_Description>An attack of this type exploits a system's trust in configuration and resource files, when the executable loads the resource (such as an image file or configuration file) the attacker has modified the file to either execute malicious code directly or manipulate the target process (e.g. application server) to execute based on the malicious configuration parameters. Since systems are increasingly interrelated mashing up resources from local and remote sources the possibility of this attack occurring is high. The attack can be directed at a client system, such as causing buffer overrun through loading seemingly benign image files, as in Microsoft Security Bulletin MS04-028 where specially crafted JPEG files could cause a buffer overrun once loaded into the browser. Another example targets clients reading pdf files. In this case the attacker simply appends javascript to the end of a legitimate url for a pdf (http://www.gnucitizen.org/blog/danger-danger-danger/) http://path/to/pdf/file.pdf#whatever_name_you_want=javascript:your_code_here The client assumes that they are reading a pdf, but the attacker has modified the resource and loaded executable javascript into the client's browser process. The attack can also target server processes. The attacker edits the resource or configuration file, for example a web.xml file used to configure security permissions for a J2EE app server, adding role name "public" grants all users with the public role the ability to use the administration functionality. The server trusts its configuration file to be correct, but when they are manipulated, the attacker gains full control.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker must have the ability to modify non-executable files consumed by the target software.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="36" name="Using Unpublished Web Service APIs">
		<capec:Attack_Pattern_Description>An attacker searches for and invokes Web Services APIs that the target system designers did not intend to be publicly available. If these APIs fail to authenticate requests the attacker may be able to invoke services and/or gain privileges they are not authorized for.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The architecture under attack must publish or otherwise make available services, of some kind, that clients can attach to, either in an unauthenticated fashion, or having obtained an authentication token elsewhere.
			The service need not be 'discoverable' but in the event it isn't, must have some way of being discovered by an attacker.
			This might include listening on a well-known port. Ultimately, the likelihood of exploit depends on discoverability of the vulnerable service.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="33" name="HTTP Request Smuggling">
		<capec:Attack_Pattern_Description>HTTP Request Smuggling results from the discrepancies in parsing HTTP requests between HTTP entities such as web caching proxies or application firewalls. Entities such as web servers, web caching proxies, application firewalls or simple proxies often parse HTTP requests in slightly different ways. Under specific situations where there are two or more such entities in the path of the HTTP request, a specially crafted request is seen by two attacked entities as two different sets of requests. This allows certain requests to be smuggled through to a second entity without the first one realizing it.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An additional HTTP entity such as an application firewall or a web caching proxy between the attacker and the second entity such as a web server
			Differences in the way the two HTTP entities parse HTTP requests
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="34" name="HTTP Response Splitting">
		<capec:Attack_Pattern_Description>This attack uses a maliciously-crafted HTTP request in order to cause a vulnerable web server to respond with an HTTP response stream that will be interpreted by the client as two separate responses instead of one. This is possible when user-controlled input is used unvalidated as part of the response headers. The target software, the client, will interpret the injected header as being a response to a second request, thereby causing the maliciously-crafted contents be displayed and possibly cached. To achieve HTTP Response Splitting on a vulnerable web server, the attacker:</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>User-controlled input used as part of HTTP header
			Ability of attacker to inject custom strings in HTTP header
			Insufficient input validation in application to check for input sanity before using it as part of response header
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="39" name="Manipulating Opaque Client-based Data Tokens">
		<capec:Attack_Pattern_Description>In circumstances where an application holds important data client-side in tokens (cookies, URLs, data files, and so forth) that data can be manipulated. If client or server-side application components reinterpret that data as authentication tokens or data (such as store item pricing or wallet information) then even opaquely manipulating that data may bear fruit for an Attacker. In this pattern an attacker undermines the assumption that client side tokens have been adequately protected from tampering through use of encryption or obfuscation.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An attacker already has some access to the system or can steal the client based data tokens from another user who has access to the system.
			For an Attacker to viably execute this attack, some data (later interpreted by the application) must be held client-side in a way that can be manipulated without detection. This means that the data or tokens are not CRCd as part of their value or through a separate meta-data store elsewhere.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="37" name="Lifting Data Embedded in Client Distributions">
		<capec:Attack_Pattern_Description>An attacker can resort to stealing data embedded in client distributions or client code in order to gain certain information. This information can reveal confidential contents, such as account numbers, or can be used as an intermediate step in a larger attack (such as by stealing keys/credentials).</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>In order to feasibly execute this class of attacks, some valuable data must be present in client software.
			Additionally, this information must be unprotected, or protected in a flawed fashion, or through a mechanism that fails to resist reverse engineering, statistical, cryptanalytic, or other attack.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="38" name="Leveraging/Manipulating Configuration File Search Paths">
		<capec:Attack_Pattern_Description>This attack loads a malicious resource into a program's standard path used to bootstrap and/or provide contextual information for a program like a path variable or classpath. J2EE applications and other component based applications that are built from multiple binaries can have very long list of dependencies to execute. If one of these libraries and/or references is controllable by the attacker then application controls can be circumvented by the attacker. A standard UNIX path looks similar to this If the attacker modifies the path variable to point to a locale that includes malicious resources then the user unwittingly can execute commands on the attackers' behalf: This is a form of usurping control of the program and the attack can be done on the classpath, database resources, or any other resources built from compound parts. At runtime detection and blocking of this attack is nearly impossible, because the configuration allows execution.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker must be able to write to redirect search paths on the victim host.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="43" name="Exploiting Multiple Input Interpretation Layers">
		<capec:Attack_Pattern_Description>An attacker supplies the target software with input data that contains sequences of special characters designed to bypass input validation logic. This exploit relies on the target making multiples passes over the input data and processing a "layer" of special characters with each pass. In this manner, the attacker can disguise input that would otherwise be rejected as invalid by concealing it with layers of special/escape characters that are stripped off by subsequent processing steps. The goal is to first discover cases where the input validation layer executes before one or more parsing layers. That is, user input may go through the following logic in an application: In such cases, the attacker will need to provide input that will pass through the input validator, but after passing through parser2, will be converted into something that the input validator was supposed to stop.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>User input is used to construct a command to be executed on the target system or as part of the file name.
			Multiple parser passes are performed on the data supplied by the user.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="42" name="MIME Conversion">
		<capec:Attack_Pattern_Description>An attacker exploits a weakness in the MIME conversion routine to cause a buffer overflow and gain control over the mail server machine. The MIME system is designed to allow various different information formats to be interpreted and sent via e-mail. Attack points exist when data are converted to MIME compatible format and back.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target system uses a mail server.
			Mail server vendor has not released a patch for the MIME conversion routine, the patch itself has a security hole or does not fix the original problem, or the patch has not been applied to the user's system.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="41" name="Using Meta-characters in E-mail Headers to Inject Malicious Payloads">
		<capec:Attack_Pattern_Description>This type of attack involves an attacker leveraging meta-characters in email headers to inject improper behavior into email programs. Email software has become increasingly sophisticated and feature-rich. In addition, email applications are ubiquitous and connected directly to the Web making them ideal targets to launch and propagate attacks. As the user demand for new functionality in email applications grows, they become more like browsers with complex rendering and plug in routines. As more email functionality is included and abstracted from the user, this creates opportunities for attackers. Virtually all email applications do not list email header information by default, however the email header contains valuable attacker vectors for the attacker to exploit particularly if the behavior of the email client application is known. Meta-characters are hidden from the user, but can contain scripts, enumerations, probes, and other attacks against the user's system.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>This attack targets most widely deployed feature rich email applications, including web based email programs.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="40" name="Manipulating Writeable Terminal Devices">
		<capec:Attack_Pattern_Description>This attack exploits terminal devices that allow themselves to be written to by other users. The attacker sends command strings to the target terminal device hoping that the target user will hit enter and thereby execute the malicious command with their privileges. The attacker can send the results (such as copying /etc/passwd) to a known directory and collect once the attack has succeeded.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>User terminals must have a permissive access control such as world writeable that allows normal users to control data on other user's terminals.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="22" name="Exploiting Trust in Client (aka Make the Client Invisible)">
		<capec:Attack_Pattern_Description>An attack of this type exploits a programs' vulnerabilities in client/server communication channel authentication and data integrity. It leverages the implicit trust a server places in the client, or more importantly, that which the server believes is the client. An attacker executes this type of attack by placing themselves in the communication channel between client and server such that communication directly to the server is possible where the server believes it is communicating only with a valid client. There are numerous variations of this type of attack.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Server software must rely on client side formatted and validated values, and not reinforce these checks on the server side.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Spoofing
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="23" name="File System Function Injection, Content Based">
		<capec:Attack_Pattern_Description>An attack of this type exploits the host's trust in executing remote content including binary files. The files are poisoned with a malicious payload (targeting the file systems accessible by the target software) by the attacker and may be passed through standard channels such as via email, and standard web content like PDF and multimedia files. The attacker exploits known vulnerabilities or handling routines in the target processes. Vulnerabilities of this type have been found in a wide variety of commercial applications from Microsoft Office to Adobe Acrobat and Apple Safari web browser. When the attacker knows the standard handling routines and can identify vulnerabilities and entry points they can be exploited by otherwise seemingly normal content. Once the attack is executed, the attackers' program can access relative directories such as C:\Program Files or other standard system directories to launch further attacks. In a worst case scenario, these programs are combined with other propagation logic and work as a virus.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target software must consume files.
			The attacker must have access to modify files that the target software will consume.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="24" name="Filter Failure through Buffer Overflow">
		<capec:Attack_Pattern_Description>In this attack, the idea is to cause an active filter to fail by causing an oversized transaction. An attacker may try to feed overly long input strings to the program in an attempt to overwhelm the filter (by causing a buffer overflow) and hoping that the filter does not fail securely (i.e. the user input is let into the system unfiltered).</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Ability to control the length of data passed to an active filter.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="25" name="Forced Deadlock">
		<capec:Attack_Pattern_Description>This attack attempts to trigger and exploit a deadlock condition in the target software to cause a denial of service. A deadlock can occur when two or more competing actions are waiting for each other to finish, and thus neither ever does. Deadlock condition are not easy to detect.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target host has a deadlock condition. There are four conditions for a deadlock to occur, known as the Coffman conditions. [R.25.3][REF-6]
			The target host exposes an API to the user.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (other) 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="26" name="Leveraging Race Conditions">
		<capec:Attack_Pattern_Description>This attack targets a race condition occurring when multiple processes access and manipulate the same resource concurrently and the outcome of the execution depends on the particular order in which the access takes place. The attacker can leverage a race condition by "running the race", modifying the resource and modifying the normal execution flow. For instance a race condition can occur while accessing a file, the attacker can trick the system by replacing the original file with his version and cause the system to read the malicious file.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>A resource is accessed/modified concurrently by multiple processes such that a race condition exists.
			The attacker has the ability to modify the resource.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Time and State
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="27" name="Leveraging Race Conditions via Symbolic Links">
		<capec:Attack_Pattern_Description>This attack leverages the use of symbolic links (Symlinks) in order to write to sensitive files. An attacker can create a Symlink link to a target file not otherwise accessible to her. When the privileged program tries to create a temporary file with the same name as the Symlink link, it will actually write to the target file pointed to by the attackers' Symlink link. If the attacker can insert malicious content in the temporary file she will be writing to the sensitive file by using the Symlink. The race occurs because the system checks if the temporary file exists, then creates the file. The attacker would typically create the Symlink during the interval between the check and the creation of the temporary file.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker is able to create Symlink links on the target host.
			Tainted data from the attacker is used and copied to temporary files.
			The target host does insecure temporary file creation.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Time and State
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (other) 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="28" name="Fuzzing">
		<capec:Attack_Pattern_Description>Fuzzing is a software testing method that feeds randomly constructed input to the system and looks for an indication that a failure in response to that input has occurred. Fuzzing treats the system as a black box and is totally free from any preconceptions or assumptions about the system. An attacker can leverage fuzzing to try to identify weaknesses in the system. For instance fuzzing can help an attacker discover certain assumptions made in the system about user input. Fuzzing gives an attacker a quick way of potentially uncovering some of these assumptions without really knowing anything about the internals of the system. These assumptions can then be turned against the system by specially crafting user input that may allow an attacker to achieve his goals.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Injection
			Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Availability 
			Impact(Motivation):  Unexpected State 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Alter execution logic 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="29" name="Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions">
		<capec:Attack_Pattern_Description>This attack targets a race condition occurring between the time of check (state) for a resource and the time of use of a resource. The typical example is the file access. The attacker can leverage a file access race condition by "running the race", meaning that he would modify the resource between the first time the target program accesses the file and the time the target program uses the file. During that period of time, the attacker could do something such as replace the file and cause an escalation of privilege.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>A resource is access/modified concurrently by multiple processes.
			The attacker is able to modify resource.
			A race condition exists while accessing a resource.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Time and State
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Alter execution logic 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (CPU) 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="30" name="Hijacking a Privileged Thread of Execution">
		<capec:Attack_Pattern_Description>Attackers can sometimes hijack a privileged thread from the underlying system through synchronous (calling a privileged function that returns incorrectly) or asynchronous (callbacks, signal handlers, and similar) means. Having done so, the Attacker may not only likely access functionality the system's designer didn't intend for them, but they may also go undetected or deny other users essential service in a catastrophic (or insidiously subtle) way.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The application in question employs a threaded model of execution with the threads operating at, or having the ability to switch to, a higher privilege level than normal users
			In order to feasibly execute this class of attacks, the attacker must have the ability to hijack a privileged thread.
			This ability includes, but is not limited to, modifying environment variables that affect the process the thread belongs to, or providing malformed user-controllable input that causes the executing thread to fault and return to a higher privilege level or such.
			This does not preclude network-based attacks, but makes them conceptually more difficult to identify and execute.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Modification of Resources
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="32" name="Embedding Scripts in HTTP Query Strings">
		<capec:Attack_Pattern_Description>A variant of cross-site scripting called "reflected" cross-site scripting, the HTTP Query Strings attack consists of passing a malicious script inside an otherwise valid HTTP request query string. This is of significant concern for sites that rely on dynamic, user-generated content such as bulletin boards, news sites, blogs, and web enabled administration GUIs. The malicious script may steal session data, browse history, probe files, or otherwise execute attacks on the client side. Once the attacker has prepared the malicious HTTP query it is sent to a victim user (perhaps by email, IM, or posted on an online forum), who clicks on a normal looking link that contains a poison query string. This technique can be made more effective through the use of services like http://tinyurl.com/, which makes very small URLs that will redirect to very large, complex ones. The victim will not know what he is really clicking on.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Target client software must allow scripting such as JavaScript. Server software must allow display of remote generated HTML without sufficient input or output validation.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="31" name="Accessing/Intercepting/Modifying HTTP Cookies">
		<capec:Attack_Pattern_Description>This attack relies on the use of HTTP Cookies to store credentials, state information and other critical data on client systems. The first form of this attack involves accessing HTTP Cookies to mine for potentially sensitive data contained therein. The second form of this attack involves intercepting this data as it is transmitted from client to server. This intercepted information is then used by the attacker to impersonate the remote user/session. The third form is when the cookie's content is modified by the attacker before it is sent back to the server. Here the attacker seeks to convince the target server to operate on this falsified information.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Target server software must be a HTTP daemon that relies on cookies.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Modification of Resources
			API Abuse
			Protocol Manipulation
			Time and State
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="19" name="Embedding Scripts within Scripts">
		<capec:Attack_Pattern_Description>An attack of this type exploits a programs' vulnerabilities that are brought on by allowing remote hosts to execute scripts. The attacker leverages this capability to execute scripts to execute his/her own script by embedding it within other scripts that the target software is likely to execute. The attacker must have the ability to inject script into script that is likely to be executed. If this is done, then the attacker can potentially launch a variety of probes and attacks against the web server's local environment, in many cases the so-called DMZ, back end resources the web server can communicate with, and other hosts. With the proliferation of intermediaries, such as Web App Firewalls, network devices, and even printers having JVMs and Web servers, there are many locales where an attacker can inject malicious scripts. Since this attack pattern defines scripts within scripts, there are likely privileges to execute said attack on the host. Of course, these attacks are not solely limited to the server side, client side scripts like Ajax and client side JavaScript can contain malicious scripts as well. In general all that is required is for there to be sufficient privileges to execute a script, but not protected against writing.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Target software must be able to execute scripts, and also allow attacker to write/upload script
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="17" name="Accessing, Modifying or Executing Executable Files">
		<capec:Attack_Pattern_Description>An attack of this type exploits a system's configuration that allows an attacker to either directly access an executable file, for example through shell access; or in a possible worst case allows an attacker to upload a file and then execute it. Web servers, ftp servers, and message oriented middleware systems which have many integration points are particularly vulnerable, because both the programmers and the administrators must be in synch regarding the interfaces and the correct privileges for each interface.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>System's configuration must allow an attacker to directly access executable files or upload files to execute. This means that any access control system that is supposed to mediate communications between the subject and the object is set incorrectly or assumes a benign environment.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Modification of Resources
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="18" name="Embedding Scripts in Non-Script Elements">
		<capec:Attack_Pattern_Description>This attack is a form of Cross-Site Scripting (XSS) where malicious scripts are embedded in elements that are not expected to host scripts such as image tags (&amp;lt;img&amp;gt;), comments in XML documents (&amp;lt; !-CDATA-&amp;gt;), etc. These tags may not be subject to the same input validation, output validation, and other content filtering and checking routines, so this can create an opportunity for an attacker to tunnel through the application's elements and launch a XSS attack through other elements. As with all remote attacks, it is important to differentiate the ability to launch an attack (such as probing an internal network for unpatched servers) and the ability of the remote attacker to collect and interpret the output of said attack.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Target client software must be a client that allows script execution based on scripts generated by remote hosts.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="15" name="Command Delimiters">
		<capec:Attack_Pattern_Description>An attack of this type exploits a programs' vulnerabilities that allows an attacker's commands to be concatenated onto a legitimate command with the intent of targeting other resources such as the file system or database. The system that uses a filter or a blacklist input validation, as opposed to whitelist validation is vulnerable to an attacker who predicts delimiters (or combinations of delimiters) not present in the filter or blacklist. As with other injection attacks, the attacker uses the command delimiter payload as an entry point to tunnel through the application and activate additional attacks through SQL queries, shell commands, network scanning, and so on.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Software's input validation or filtering must not detect and block presence of additional malicious command.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="16" name="Dictionary-based Password Attack">
		<capec:Attack_Pattern_Description>An attacker tries each of the words in a dictionary as passwords to gain access to the system via some user's account. If the password chosen by the user was a word within the dictionary, this attack will be successful (in the absence of other mitigations). This is a specific instance of the password brute forcing attack pattern.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The system uses one factor password based authentication.
			The system does not have a sound password policy that is being enforced.
			The system does not implement an effective password throttling mechanism.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="13" name="Subverting Environment Variable Values">
		<capec:Attack_Pattern_Description>The attacker directly or indirectly modifies environment variables used by or controlling the target software. The attacker's goal is to cause the target software to deviate from its expected operation in a manner that benefits the attacker.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An environment variable is accessible to the user.
			An environment variable used by the application can be tainted with user supplied data.
			Input data used in an environment variable is not validated properly.
			The variables encapsulation is not done properly. For instance setting a variable as public in a class makes it visible and an attacker may attempt to manipulate that variable.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Modification of Resources
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
			Scope:  Availability 
			Impact(Motivation):  Unexpected State 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="14" name="Client-side Injection-induced Buffer Overflow">
		<capec:Attack_Pattern_Description>This type of attack exploits a buffer overflow vulnerability in targeted client software through injection of malicious content from a custom-built hostile service.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The targeted client software communicates with an external server.
			The targeted client software has a buffer overflow vulnerability.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>API Abuse
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (memory) 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="11" name="Cause Web Server Misclassification">
		<capec:Attack_Pattern_Description>An attack of this type exploits a Web server's decision to take action based on filename or file extension. Because different file types are handled by different server processes, misclassification may force the Web server to take unexpected action, or expected actions in an unexpected sequence. This may cause the server to exhaust resources, supply debug or system data to the attacker, or bind an attacker to a remote process. This type of vulnerability has been found in many widely used servers including IIS, Lotus Domino, and Orion. The attacker's job in this case is straightforward, standard communication protocols and methods are used and are generally appended with malicious information at the tail end of an otherwise legitimate request. The attack payload varies, but it could be special characters like a period or simply appending a tag that has a special meaning for operations on the server side like .jsp for a java application server. The essence of this attack is that the attacker deceives the server into executing functionality based on the name of the request, i.e. login.jsp, not the contents.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Web server software must rely on file name or file extension for processing.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read memory Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="12" name="Choosing a Message/Channel Identifier on a Public/Multicast Channel">
		<capec:Attack_Pattern_Description>Attackers aware that more data is being fed into a multicast or public information distribution means can 'select' information bound only for another client, even if the distribution means itself forces users to authenticate in order to connect initially. Doing so allows the attacker to gain access to possibly privileged information, possibly perpetrate other attacks through the distribution means by impersonation. If the channel/message being manipulated is an input rather than output mechanism for the system, (such as a command bus), this style of attack could change its identifier from a less privileged to more so privileged channel or command.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Information and client-sensitive (and client-specific) data must be present through a distribution channel available to all users.
			Distribution means must code (through channel, message identifiers, or convention) message destination in a manner visible within the distribution means itself (such as a control channel) or in the messages themselves.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="21" name="Exploitation of Session Variables, Resource IDs and other Trusted Credentials">
		<capec:Attack_Pattern_Description>Attacks on session IDs and resource IDs take advantage of the fact that some software accepts user input without verifying its authenticity. For example, a message queuing system that allows service requesters to post messages to its queue through an open channel (such as anonymous FTP), authorization is done through checking group or role membership contained in the posted message. However, there is no proof that the message itself, the information in the message (such group or role membership), or indeed the process that wrote the message to the queue are authentic and authorized to do so. Many server side processes are vulnerable to these attacks because the server to server communications have not been analyzed from a security perspective or the processes "trust" other systems because they are behind a firewall. In a similar way servers that use easy to guess or spoofable schemes for representing digital identity can also be vulnerable. Such systems frequently use schemes without cryptography and digital signatures (or with broken cryptography). Session IDs may be guessed due to insufficient randomness, poor protection (passed in the clear), lack of integrity (unsigned), or improperly correlation with access control policy enforcement points. Exposed configuration and properties files that contain system passwords, database connection strings, and such may also give an attacker an edge to identify these identifiers. The net result is that spoofing and impersonation is possible leading to an attacker's ability to break authentication, authorization, and audit controls on the system.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Server software must rely on weak session IDs proof and/or verification schemes
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Spoofing
			API Abuse
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="20" name="Encryption Brute Forcing">
		<capec:Attack_Pattern_Description>An attacker, armed with the cipher text and the encryption algorithm used, performs an exhaustive (brute force) search on the key space to determine the key that decrypts the cipher text to obtain the plaintext.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Ciphertext is known.
			Encryption algorithm and key size are known.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="10" name="Buffer Overflow via Environment Variables">
		<capec:Attack_Pattern_Description>This attack pattern involves causing a buffer overflow through manipulation of environment variables. Once the attacker finds that they can modify an environment variable, they may try to overflow associated buffers. This attack leverages implicit trust often placed in environment variables.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The application uses environment variables.
			An environment variable exposed to the user is vulnerable to a buffer overflow.
			The vulnerable environment variable uses untrusted data.
			Tainted data used in the environment variables is not properly validated. For instance boundary checking is not done before copying the input data to a buffer.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="79" name="Using Slashes in Alternate Encoding">
		<capec:Attack_Pattern_Description>This attack targets the encoding of the Slash characters. An attacker would try to exploit common filtering problems related to the use of the slashes characters to gain access to resources on the target host. Directory-driven systems, such as file systems and databases, typically use the slash character to indicate traversal between directories or other container components. For murky historical reasons, PCs (and, as a result, Microsoft OSs) choose to use a backslash, whereas the UNIX world typically makes use of the forward slash. The schizophrenic result is that many MS-based systems are required to understand both forms of the slash. This gives the attacker many opportunities to discover and abuse a number of common filtering problems. The goal of this pattern is to discover server software that only applies filters to one version, but not the other.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The application server accepts paths to locate resources.
			The application server does insufficient input data validation on the resource path requested by the user.
			The access right to resources are not set properly.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="78" name="Using Escaped Slashes in Alternate Encoding">
		<capec:Attack_Pattern_Description>This attack targets the use of the backslash in alternate encoding. An attacker can provide a backslash as a leading character and causes a parser to believe that the next character is special. This is called an escape. By using that trick, the attacker tries to exploit alternate ways to encode the same character which leads to filter problems and opens avenues to attack.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The application accepts the backlash character as escape character.
			The application server does incomplete input data decoding, filtering and validation.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data Read files or directories 
			Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (memory) 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="77" name="Manipulating User-Controlled Variables">
		<capec:Attack_Pattern_Description>This attack targets user controlled variables (DEBUG=1, PHP Globals, and So Forth). An attacker can override environment variables leveraging user-supplied, untrusted query variables directly used on the application server without any data sanitization. In extreme cases, the attacker can change variables controlling the business logic of the application. For instance, in languages like PHP, a number of poorly set default configurations may allow the user to override variables.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>A variable consumed by the application server is exposed to the client.
			A variable consumed by the application server can be overwritten by the user.
			The application server trusts user supplied data to compute business logic.
			The application server does not perform proper input validation.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="82" name="Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))">
		<capec:Attack_Pattern_Description>XML Denial of Service (XDoS) can be applied to any technology that utilizes XML data. This is, of course, most distributed systems technology including Java, .Net, databases, and so on. XDoS is most closely associated with web services, SOAP, and Rest, because remote service requesters can post malicious XML payloads to the service provider designed to exhaust the service provider's memory, CPU, and/or disk space. The main weakness in XDoS is that the service provider generally must inspect, parse, and validate the XML messages to determine routing, workflow, security considerations, and so on. It is exactly these inspection, parsing, and validation routines that XDoS targets. There are three primary attack vectors that XDoS can navigate Target CPU through recursion: attacker creates a recursive payload and sends to service provider Target memory through jumbo payloads: service provider uses DOM to parse XML. DOM creates in memory representation of XML document, but when document is very large (for example, north of 1 Gb) service provider host may exhaust memory trying to build memory objects. XML Ping of death: attack service provider with numerous small files that clog the system. All of the above attacks exploit the loosely coupled nature of web services, where the service provider has little to no control over the service requester and any messages the service requester sends.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Attacker must be able to send a malicious XML payload to host, such as SOAP or REST web service.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (memory) 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="83" name="XPath Injection">
		<capec:Attack_Pattern_Description>An attacker can craft special user-controllable input consisting of XPath expressions to inject the XML database and bypass authentication or glean information that he normally would not be able to. XPath Injection enables an attacker to talk directly to the XML database, thus bypassing the application completely. XPath Injection results from the failure of an application to properly sanitize input used as part of dynamic XPath expressions used to query an XML database. In order to successfully inject XML and retrieve information from a database, an attacker:</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>XPath queries used to retrieve information stored in XML documents
			User-controllable input not properly sanitized before being used as part of XPath queries
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="80" name="Using UTF-8 Encoding to Bypass Validation Logic">
		<capec:Attack_Pattern_Description>This attack is a specific variation on leveraging alternate encodings to bypass validation logic. This attack leverages the possibility to encode potentially harmful input in UTF-8 and submit it to applications not expecting or effective at validating this encoding standard making input filtering difficult. UTF-8 (8-bit UCS/Unicode Transformation Format) is a variable-length character encoding for Unicode. Legal UTF-8 characters are one to four bytes long. However, early version of the UTF-8 specification got some entries wrong (in some cases it permitted overlong characters). UTF-8 encoders are supposed to use the "shortest possible" encoding, but naive decoders may accept encodings that are longer than necessary. According to the RFC 3629, a particularly subtle form of this attack can be carried out against a parser which performs security-critical validity checks against the UTF-8 encoded form of its input, but interprets certain illegal octet sequences as characters.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The application's UTF-8 decoder accepts and interprets illegal UTF-8 characters or non-shortest format of UTF-8 encoding.
			Input filtering and validating is not done properly leaving the door open to harmful characters for the target host.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Availability 
			Impact(Motivation):  Unexpected State 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="81" name="Web Logs Tampering">
		<capec:Attack_Pattern_Description>Web Logs Tampering attacks involve an attacker injecting, deleting or otherwise tampering with the contents of web logs typically for the purposes of masking other malicious behavior. Additionally, writing malicious data to log files may target jobs, filters, reports, and other agents that process the logs in an asynchronous attack pattern. This pattern of attack is similar to "Log Injection-Tampering-Forging" except that in this case, the attack is targeting the logs of the web server and not the application.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Target server software must be a HTTP server that performs web logging.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Modification of Resources
			Time and State
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="86" name="Embedding Script (XSS) in HTTP Headers">
		<capec:Attack_Pattern_Description>An attack of this type exploits web applications that generate web content, such as links in a HTML page, based on unvalidated or improperly validated data submitted by other actors. XSS in HTTP Headers attacks target the HTTP headers which are hidden from most users and may not be validated by web applications.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Target software must be a client that allows scripting communication from remote hosts, and attacker must control a remote site of some sort to redirect client and data to.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Modification of Resources
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="87" name="Forceful Browsing">
		<capec:Attack_Pattern_Description>An attacker employs forceful browsing to access portions of a website that are otherwise unreachable through direct URL entry. Usually, a front controller or similar design pattern is employed to protect access to portions of a web application. Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web application that have been improperly protected.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The forcibly browseable pages or accessible resources must be discoverable and improperly protected.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="84" name="XQuery Injection">
		<capec:Attack_Pattern_Description>This attack utilizes XQuery to probe and attack server systems; in a similar manner that SQL Injection allows an attacker to exploit SQL calls to RDBMS, XQuery Injection uses improperly validated data that is passed to XQuery commands to traverse and execute commands that the XQuery routines have access to. XQuery injection can be used to enumerate elements on the victim's environment, inject commands to the local host, or execute queries to remote files and data sources.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The XQL must execute unvalidated data
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="85" name="AJAX Fingerprinting">
		<capec:Attack_Pattern_Description>This attack utilizes the frequent client-server roundtrips in Ajax conversation to scan a system. While Ajax does not open up new vulnerabilities per se, it does optimize them from an attacker point of view. In many XSS attacks the attacker must get a "hole in one" and successfully exploit the vulnerability on the victim side the first time, once the client is redirected the attacker has many chances to engage in follow on probes, but there is only one first chance. In a widely used web application this is not a major problem because 1 in a 1,000 is good enough in a widely used application. A common first step for an attacker is to footprint the environment to understand what attacks will work. Since footprinting relies on enumeration, the conversational pattern of rapid, multiple requests and responses that are typical in Ajax applications enable an attacker to look for many vulnerabilities, well-known ports, network locations and so on.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The user must allow JavaScript to execute in their browser
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Injection
			Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="67" name="String Format Overflow in syslog()">
		<capec:Attack_Pattern_Description>This attack targets the format string vulnerabilities in the syslog() function. An attacker would typically inject malicious input in the format string parameter of the syslog function. This is a common problem, and many public vulnerabilities and associated exploits have been posted.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The format string argument of the Syslog function can be tainted with user supplied data.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="66" name="SQL Injection">
		<capec:Attack_Pattern_Description>This attack exploits target software that constructs SQL statements based on user input. An attacker crafts input strings so that when the target software constructs SQL statements based on the input, the resulting SQL statement performs actions other than those the application intended. SQL Injection results from failure of the application to appropriately validate input. When specially crafted user-controlled input consisting of SQL syntax is used without proper validation as part of SQL queries, it is possible to glean information from the database in ways not envisaged during application design. Depending upon the database and the design of the application, it may also be possible to leverage injection to have the database execute system-related commands of the attackers' choice. SQL Injection enables an attacker to talk directly to the database, thus bypassing the application completely. Successful injection can cause information disclosure as well as ability to add or modify data in the database. In order to successfully inject SQL and retrieve information from a database, an attacker:</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>SQL queries used by the application to store, retrieve or modify data.
			User-controllable input that is not properly validated by the application as part of SQL queries.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="69" name="Target Programs with Elevated Privileges">
		<capec:Attack_Pattern_Description>This attack targets programs running with elevated privileges. The attacker would try to leverage a bug in the running program and get arbitrary code to execute with elevated privileges. For instance an attacker would look for programs that write to the system directories or registry keys (such as HKLM, which stores a number of critical Windows environment variables). These programs are typically running with elevated privileges and have usually not been designed with security in mind. Such programs are excellent exploit targets because they yield lots of power when they break. The malicious user try to execute its code at the same level as a privileged system call.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The targeted program runs with elevated OS privileges.
			The targeted program accepts input data from the user or from another program.
			The targeted program does not perform input validation properly.
			The targeted program does not fail safely. For instance when a program fails it may authorize restricted access to anyone.
			The targeted program has a vulnerability such as buffer overflow which may be exploited if a malicious user can inject unvalidated data. For instance a buffer overflow interrupts the program as it executes, and makes it run additional code supplied by the attacker. If the program under attack has elevated privileges to the OS, the attacker can elevate its privileges (such as having root level access).
			The targeted program is giving away information about itself. Before performing such attack, an eventual attacker may need to gather information about the services running on the host target. The more the host target is verbose about the services that are running (version number of application, etc.) the more information can be gather by an attacker.
			This attack often requires communicating with the host target services directly. For instance Telnet may be enough to communicate with the host target.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
			Protocol Manipulation
			Flooding
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (memory) 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="68" name="Subvert Code-signing Facilities">
		<capec:Attack_Pattern_Description>Because languages use code signing facilities to vouch for code's identity and to thus tie code to its assigned privileges within an environment, subverting this mechanism can be instrumental in an attacker escalating privilege. Any means of subverting the way that a virtual machine enforces code signing classifies for this style of attack. This pattern does not include circumstances through which a signing key has been stolen.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>A framework-based language that supports code signing (such as, and most commonly, Java or .NET)
			Deployed code that has been signed by its authoring vendor, or a partner.
			The attacker will, for most circumstances, also need to be able to place code in the victim container. This does not necessarily mean that they will have to subvert host-level security, except when explicitly indicated.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Spoofing
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="70" name="Try Common(default) Usernames and Passwords">
		<capec:Attack_Pattern_Description>An attacker may try certain common (default) usernames and passwords to gain access into the system and perform unauthorized actions. An attacker may try an intelligent brute force using known vendor default credentials as well as a dictionary of common usernames and passwords. Many vendor products come preconfigured with default (and thus well-known) usernames and passwords that should be deleted prior to usage in a production environment. It is a common mistake to forget to remove these default login credentials. Another problem is that users would pick very simple (common) passwords (e.g. "secret" or "password") that make it easier for the attacker to gain access to the system compared to using a brute force attack or even a dictionary attack using a full dictionary.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The system uses one factor password based authentication.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="71" name="Using Unicode Encoding to Bypass Validation Logic">
		<capec:Attack_Pattern_Description>An attacker may provide a Unicode string to a system component that is not Unicode aware and use that to circumvent the filter or cause the classifying mechanism to fail to properly understanding the request. That may allow the attacker to slip malicious data past the content filter and/or possibly cause the application to route the request incorrectly.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Filtering is performed on data that has not be properly canonicalized.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Modification of Resources
			API Abuse
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="72" name="URL Encoding">
		<capec:Attack_Pattern_Description>This attack targets the encoding of the URL. An attacker can take advantage of the multiple way of encoding an URL and abuse the interpretation of the URL. An URL may contain special character that need special syntax handling in order to be interpreted. Special characters are represented using a percentage character followed by two digits representing the octet code of the original character (%HEX-CODE). For instance US-ASCII space character would be represented with %20. This is often referred as escaped ending or percent-encoding. Since the server decodes the URL from the requests, it may restrict the access to some URL paths by validating and filtering out the URL requests it received. An attacker will try to craft an URL with a sequence of special characters which once interpreted by the server will be equivalent to a forbidden URL. It can be difficult to protect against this attack since the URL can contain other format of encoding such as UTF-8 encoding, Unicode-encoding, etc. The attacker could also subvert the meaning of the URL string request by encoding the data being sent to the server through a GET request. For instance an attacker may subvert the meaning of parameters used in a SQL request and sent through the URL string (See Example section).</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The application should accepts and decodes URL input.
			The application performs insufficient filtering/canonicalization on the URLs.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (memory) 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="73" name="User-Controlled Filename">
		<capec:Attack_Pattern_Description>An attack of this type involves an attacker inserting malicious characters (such as a XSS redirection) into a filename, directly or indirectly that is then used by the target software to generate HTML text or other potentially executable content. Many websites rely on user-generated content and dynamically build resources like files, filenames, and URL links directly from user supplied data. In this attack pattern, the attacker uploads code that can execute in the client browser and/or redirect the client browser to a site that the attacker owns. All XSS attack payload variants can be used to pass and exploit these vulnerabilities.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The victim must trust the name and locale of user controlled filenames.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Availability 
			Impact(Motivation):  Alter execution logic 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="74" name="Manipulating User State">
		<capec:Attack_Pattern_Description>An attacker modifies state information maintained by the target software in user-accessible locations. If successful, the target software will use this tainted state information and execute in an unintended manner. State management is an important function within an application. User state maintained by the application can include usernames, payment information, browsing history as well as application-specific contents such as items in a shopping cart. Manipulating user state can be employed by an attacker to elevate privilege, conduct fraudulent transactions or otherwise modify the flow of the application to derive certain benefits.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="75" name="Manipulating Writeable Configuration Files">
		<capec:Attack_Pattern_Description>Generally these are manually edited files that are not in the preview of the system administrators, any ability on the attackers' behalf to modify these files, for example in a CVS repository, gives unauthorized access directly to the application, the same as authorized users.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Configuration files must be modifiable by the attacker
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="76" name="Manipulating Input to File System Calls">
		<capec:Attack_Pattern_Description>An attacker manipulates inputs to the target software which the target software passes to file system calls in the OS. The goal is to gain access to, and perhaps modify, areas of the file system that the target software did not intend to be accessible.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Program must allow for user controlled variables to be applied directly to the filesystem
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="59" name="Session Credential Falsification through Prediction">
		<capec:Attack_Pattern_Description>This attack targets predictable session ID in order to gain privileges. The attacker can predict the session ID used during a transaction to perform spoofing and session hijacking.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target host uses session IDs to keep track of the users.
			Session IDs are used to control access to resources.
			The session IDs used by the target host are predictable. For example, the session IDs are generated using predictable information (e.g., time).
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Spoofing
			Brute Force
			Analysis
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="58" name="Restful Privilege Elevation">
		<capec:Attack_Pattern_Description>Rest uses standard HTTP (Get, Put, Delete) style permissions methods, but these are not necessarily correlated generally with back end programs. Strict interpretation of HTTP get methods means that these HTTP Get services should not be used to delete information on the server, but there is no access control mechanism to back up this logic. This means that unless the services are properly ACL'd and the application's service implementation are following these guidelines then an HTTP request can easily execute a delete or update on the server side. The attacker identifies a HTTP Get URL such as http://victimsite/updateOrder, which calls out to a program to update orders on a database or other resource. The URL is not idempotent so the request can be submitted multiple times by the attacker, additionally, the attacker may be able to exploit the URL published as a Get method that actually performs updates (instead of merely retrieving data). This may result in malicious or inadvertent altering of data on the server.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker needs to be able to identify HTTP Get URLs. The Get methods must be set to call applications that perform operations other than get such as update and delete.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="57" name="Utilizing REST's Trust in the System Resource to Register Man in the Middle">
		<capec:Attack_Pattern_Description>This attack utilizes a REST(REpresentational State Transfer)-style applications' trust in the system resources and environment to place man in the middle once SSL is terminated. Rest applications premise is that they leverage existing infrastructure to deliver web services functionality. An example of this is a Rest application that uses HTTP Get methods and receives a HTTP response with an XML document. These Rest style web services are deployed on existing infrastructure such as Apache and IIS web servers with no SOAP stack required. Unfortunately from a security standpoint, there frequently is no interoperable identity security mechanism deployed, so Rest developers often fall back to SSL to deliver security. In large data centers, SSL is typically terminated at the edge of the network - at the firewall, load balancer, or router. Once the SSL is terminated the HTTP request is in the clear (unless developers have hashed or encrypted the values, but this is rare). The attacker can utilize a sniffer such as Wireshark to snapshot the credentials, such as username and password that are passed in the clear once SSL is terminated. Once the attacker gathers these credentials, they can submit requests to the web service provider just as authorized user do. There is not typically an authentication on the client side, beyond what is passed in the request itself so once this is compromised, then this is generally sufficient to compromise the service's authentication scheme.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Opportunity to intercept must exist beyond the point where SSL is terminated.
			The attacker must be able to insert a listener actively (proxying the communication) or passively (sniffing the communication) in the client-server communication path.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="56" name="Removing/short-circuiting 'guard logic'">
		<capec:Attack_Pattern_Description>Attackers can, in some cases, get around logic put in place to 'guard' sensitive functionality or data. The attack may involve gaining access to and calling protected functionality (or accessing protected data) directly, may involve subverting some aspect of the guard's implementation, or outright removal of the guard, if possible.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The Attacker must have reverse-engineered the application and its design extensively enough to have determined that a guard element exists. This may have been done as simply as through probing (and likely receiving too verbose an error message) or could have involved high-brow techniques supported by advanced reverse engineering/debugging tools.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="55" name="Rainbow Table Password Cracking">
		<capec:Attack_Pattern_Description>An attacker gets access to the database table where hashes of passwords are stored. He then uses a rainbow table of pre-computed hash chains to attempt to look up the original password. Once the original password corresponding to the hash is obtained, the attacker uses the original password to gain access to the system. A password rainbow table stores hash chains for various passwords. A password chain is computed, starting from the original password, P, via a reduce(compression) function R and a hash function H. A recurrence relation exists where Xi+1 = R(H(Xi)), X0 = P. Then the hash chain of length n for the original password P can be formed: X1, X2, X3, ... , Xn-2, Xn-1, Xn, H(Xn). P and H(Xn) are then stored together in the rainbow table. Constructing the rainbow tables takes a very long time and is computationally expensive. A separate table needs to be constructed for the various hash algorithms (e.g. SHA1, MD5, etc.). However, once a rainbow table is computed, it can be very effective in cracking the passwords that have been hashed without the use of salt.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Hash of the original password is available to the attacker. For a better chance of success, an attacker should have more than one hash of the original password, and ideally the whole table.
			Salt was not used to create the hash of the original password. Otherwise the rainbow tables have to be re-computed, which is very expensive and will make the attack effectively infeasible (especially if salt was added in iterations).
			The system uses one factor password based authentication.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="64" name="Using Slashes and URL Encoding Combined to Bypass Validation Logic">
		<capec:Attack_Pattern_Description>This attack targets the encoding of the URL combined with the encoding of the slash characters. An attacker can take advantage of the multiple way of encoding an URL and abuse the interpretation of the URL. An URL may contain special character that need special syntax handling in order to be interpreted. Special characters are represented using a percentage character followed by two digits representing the octet code of the original character (%HEX-CODE). For instance US-ASCII space character would be represented with %20. This is often referred as escaped ending or percent-encoding. Since the server decodes the URL from the requests, it may restrict the access to some URL paths by validating and filtering out the URL requests it received. An attacker will try to craft an URL with a sequence of special characters which once interpreted by the server will be equivalent to a forbidden URL. It can be difficult to protect against this attack since the URL can contain other format of encoding such as UTF-8 encoding, Unicode-encoding, etc.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The application accepts and decodes URL string request.
			The application performs insufficient filtering/canonicalization on the URLs.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (other) 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="65" name="Passively Sniff and Capture Application Code Bound for Authorized Client">
		<capec:Attack_Pattern_Description>Attackers can capture application code bound for the client and can use it, as-is or through reverse-engineering, to glean sensitive information or exploit the trust relationship between the client and server. Such code may belong to a dynamic update to the client, a patch being applied to a client component or any such interaction where the client is authorized to communicate with the server.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker must have the ability to place himself in the communication path between the client and server.
			The targeted application must receive some application code from the server; for example, dynamic updates, patches, applets or scripts.
			The attacker must be able to employ a sniffer on the network without being detected.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="62" name="Cross Site Request Forgery (aka Session Riding)">
		<capec:Attack_Pattern_Description>An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users' privilege level. This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user's system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply "riding" the existing session cookie.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>empty
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Spoofing
			Analysis
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="63" name="Simple Script Injection">
		<capec:Attack_Pattern_Description>An attacker embeds malicious scripts in content that will be served to web browsers. The goal of the attack is for the target software, the client-side browser, to execute the script with the users' privilege level. An attack of this type exploits a programs' vulnerabilities that are brought on by allowing remote hosts to execute code and scripts. Web browsers, for example, have some simple security controls in place, but if a remote attacker is allowed to execute scripts (through injecting them in to user-generated content like bulletin boards) then these controls may be bypassed. Further, these attacks are very difficult for an end user to detect.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Target client software must be a client that allows scripting communication from remote hosts, such as a JavaScript-enabled Web Browser
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Modification of Resources
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="60" name="Reusing Session IDs (aka Session Replay)">
		<capec:Attack_Pattern_Description>This attack targets the reuse of valid session ID to spoof the target system in order to gain privileges. The attacker tries to reuse a stolen session ID used previously during a transaction to perform spoofing and session hijacking. Another name for this type of attack is Session Replay.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target host uses session IDs to keep track of the users.
			Session IDs are used to control access to resources.
			The session IDs used by the target host are not well protected from session theft.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Spoofing
			Social Engineering
			Analysis
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="61" name="Session Fixation">
		<capec:Attack_Pattern_Description>The attacker induces a client to establish a session with the target software using a session identifier provided by the attacker. Once the user successfully authenticates to the target software, the attacker uses the (now privileged) session identifier in their own transactions. This attack leverages the fact that the target software either relies on client-generated session identifiers or maintains the same session identifiers after privilege elevation.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Session identifiers that remain unchanged when the privilege levels change.
			Permissive session management mechanism that accepts random user-generated session identifiers
			Predictable session identifiers
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Time and State
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="49" name="Password Brute Forcing">
		<capec:Attack_Pattern_Description>In this attack, the attacker tries every possible value for a password until they succeed. A brute force attack, if feasible computationally, will always be successful because it will essentially go through all possible passwords given the alphabet used (lower case letters, upper case letters, numbers, symbols, etc.) and the maximum length of the password. A system will be particularly vulnerable to this type of an attack if it does not have a proper enforcement mechanism in place to ensure that passwords selected by users are strong passwords that comply with an adequate password policy. In practice a pure brute force attack on passwords is rarely used, unless the password is suspected to be weak. Other password cracking methods exist that are far more effective (e.g. dictionary attacks, rainbow tables, etc.).</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An attacker needs to know a username to target.
			The system uses password based authentication as the one factor authentication mechanism.
			An application does not have a password throttling mechanism in place. A good password throttling mechanism will make it almost impossible computationally to brute force a password as it may either lock out the user after a certain number of incorrect attempts or introduce time out periods. Both of these would make a brute force attack impractical.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="48" name="Passing Local Filenames to Functions That Expect a URL">
		<capec:Attack_Pattern_Description>This attack relies on client side code to access local files and resources instead of URLs. When the client browser is expecting a URL string, but instead receives a request for a local file, that execution is likely to occur in the browser process space with the browser's authority to local files. The attacker can send the results of this request to the local files out to a site that they control. This attack may be used to steal sensitive authentication data (either local or remote), or to gain system profile information to launch further attacks.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The victim's software must not differentiate between the location and type of reference passed the client software, e.g. browser
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>API Abuse
			Modification of Resources
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="45" name="Buffer Overflow via Symbolic Links">
		<capec:Attack_Pattern_Description>This type of attack leverages the use of symbolic links to cause buffer overflows. An attacker can try to create or manipulate a symbolic link file such that its contents result in out of bounds data. When the target software processes the symbolic link file, it could potentially overflow internal buffers with insufficient bounds checking.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker can create symbolic link on the target host.
			The target host does not perform correct boundary checking while consuming data from a resources.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="44" name="Overflow Binary Resource File">
		<capec:Attack_Pattern_Description>An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the attacker access to the execution stack and execute arbitrary code in the target process. This attack pattern is a variant of standard buffer overflow attacks using an unexpected vector (binary files) to wrap its attack and open up a new attack vector. The attacker is required to either directly serve the binary content to the victim, or place it in a locale like a MP3 sharing application, for the victim to download. The attacker then is notified upon the download or otherwise locates the vulnerability opened up by the buffer overflow.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Target software processes binary resource files.
			Target software contains a buffer overflow vulnerability reachable through input from a user-controllable binary resource file.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="47" name="Buffer Overflow via Parameter Expansion">
		<capec:Attack_Pattern_Description>In this attack, the target software is given input that the attacker knows will be modified and expanded in size during processing. This attack relies on the target software failing to anticipate that the expanded data may exceed some internal limit, thereby creating a buffer overflow.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The program expands one of the parameters passed to a function with input controlled by the user, but a later function making use of the expanded parameter erroneously considers the original, not the expanded size of the parameter.
			The expanded parameter is used in the context where buffer overflow may become possible due to the incorrect understanding of the parameter size (i.e. thinking that it is smaller than it really is).
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="46" name="Overflow Variables and Tags">
		<capec:Attack_Pattern_Description>This type of attack leverages the use of tags or variables from a formatted configuration data to cause buffer overflow. The attacker crafts a malicious HTML page or configuration file that includes oversized strings, thus causing an overflow.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target program consumes user-controllable data in the form of tags or variables.
			The target program does not perform sufficient boundary checking.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="51" name="Poison Web Service Registry">
		<capec:Attack_Pattern_Description>SOA and Web Services often use a registry to perform look up, get schema information, and metadata about services. A poisoned registry can redirect (think phishing for servers) the service requester to a malicious service provider, provide incorrect information in schema or metadata (to effect a denial of service), and delete information about service provider interfaces. WS-Addressing is used to virtualize services, provide return addresses and other routing information, however, unless the WS-Addressing headers are protected they are vulnerable to rewriting. The attacker that can rewrite WS-addressing information gains the ability to route service requesters to any service providers, and the ability to route service provider response to any service. Content in a registry is deployed by the service provider. The registry in an SOA or Web Services system can be accessed by the service requester via UDDI or other protocol. The basic flow for the attacker consists of either altering the data at rest in the registry or uploading malicious content by spoofing a service provider. The service requester is then redirected to send its requests and/or responses to services the attacker controls.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker must be able to write to resources or redirect access to the service registry.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Modification of Resources
			Injection
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="52" name="Embedding NULL Bytes">
		<capec:Attack_Pattern_Description>An attacker embeds one or more null bytes in input to the target software. This attack relies on the usage of a null-valued byte as a string terminator in many environments. The goal is for certain components of the target software to stop processing the input when it encounters the null byte(s).</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The program does not properly handle postfix NULL terminators
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Modification of Resources
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="53" name="Postfix, Null Terminate, and Backslash">
		<capec:Attack_Pattern_Description>If a string is passed through a filter of some kind, then a terminal NULL may not be valid. Using alternate representation of NULL allows an attacker to embed the NULL mid-string while postfixing the proper data so that the filter is avoided. One example is a filter that looks for a trailing slash character. If a string insertion is possible, but the slash must exist, an alternate encoding of NULL in mid-string may be used.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Null terminators are not properly handled by the filter.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="54" name="Probe Application Error Reporting">
		<capec:Attack_Pattern_Description>An Attacker, aware of an application's location (and possibly authorized to use the application) can probe the application's structure and evaluate its robustness by probing its error conditions (not unlike one would during a 'fuzz' test, but more purposefully here) in order to support attacks such as blind SQL injection, or for the more general task of mapping the application to mount another subsequent attack.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>This class of attacks does not strictly require authorized access to the application. As Attackers use this attack process to classify, map, and identify vulnerable aspects of an application, it simply requires hypotheses to be verified, interaction with the application, and time to conduct trial-and-error activities.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data Read memory 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="50" name="Password Recovery Exploitation">
		<capec:Attack_Pattern_Description>An attacker may take advantage of the application feature to help users recover their forgotten passwords in order to gain access into the system with the same privileges as the original user. Generally password recovery schemes tend to be weak and insecure. Most of them use only one security question . For instance, mother's maiden name tends to be a fairly popular one. Unfortunately in many cases this information is not very hard to find, especially if the attacker knows the legitimate user. These generic security questions are also re-used across many applications, thus making them even more insecure. An attacker could for instance overhear a coworker talking to a bank representative at the work place and supplying their mother's maiden name for verification purposes. An attacker can then try to log in into one of the victim's accounts, click on "forgot password" and there is a good chance that the security question there will be to provide mother's maiden name. A weak password recovery scheme totally undermines the effectiveness of a strong password scheme.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The system allows users to recover their passwords and gain access back into the system.
			Password recovery mechanism has been designed or implemented insecurely.
			Password recovery mechanism relies only on something the user knows and not something the user has.
			No third party intervention is required to use the password recovery mechanism.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Brute Force
			API Abuse
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="485" name="Signature Spoofing by Key Recreation">
		<capec:Attack_Pattern_Description>An attacker obtains an authoritative or reputable signer's private signature key by exploiting a cryptographic weakness in the signature algorithm or pseudorandom number generation and then uses this key to forge signatures from the original signer to mislead a victim into performing actions that benefit the attacker.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An authoritative signer is using a weak method of random number generation or weak signing software that causes key leakage or permits key inference.
			An authoritative signer is using a signature algorithm with a direct weakness or with poorly chosen parameters that enable the key to be recovered using signatures from that signer.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Analysis
			API Abuse
			Brute Force
			Spoofing
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence> empty 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="484" name="XML Client-Side Attack">
		<capec:Attack_Pattern_Description>Client applications such as web browsers that process HTML data often need to transform data in and out of the XML format by using an XML parser. It may be possible for an attacker to inject data that may have an adverse effect on the XML parser when it is being processed. These adverse effects may include the parser crashing, consuming too much of a resource, executing too slowly, executing code supplied by an attacker, allowing usage of unintended system functionality, etc. An attacker's goal is to leverage parser failure to his or her advantage. In some cases it may be possible to jump from the data plane to the control plane via bad data being passed to an XML parser. [R.484.1]</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An application uses an XML parser to perform transformation on user-controllable data.
			An application does not perform sufficient validation to ensure that user-controllable data is safe for an XML parser.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (memory) 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="289" name="DEPRECATED: Infrastructure-based footprinting">
		<capec:Attack_Pattern_Description>"Infrastructure-based footprinting involves interacting with available network or application resources for the purpose of gathering information about the architecture, topology, configuration, or potential vulnerabilities and exposures of a target networking infrastructure."</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="287" name="TCP SYN Scan">
		<capec:Attack_Pattern_Description>An attacker uses a SYN scan to determine the status of ports on the remote target. SYN scanning is the most common type of port scanning that is used because of its enormous advantages and few drawbacks. As a result, novice attackers tend to overly rely on the SYN scan while performing system reconnaissance. As a scanning method the primary advantages of SYN scanning are its universality and speed. RFC 793 defines the required behavior of any TCP/IP device in that an incoming connection request begins with a SYN packet, which in turn must be followed by a SYN/ACK packet from the receiving service. For this reason, like TCP Connect scanning, SYN scanning works against any TCP stack. Unlike TCP Connect scanning, it is possible to scan thousands of ports per second using this method. This type of scanning is usually referred to as 'half-open' scanning because it does not complete the three-way handshake. The scanning rate is extremely fast because no time is wasted completing the handshake or tearing down the connection. TCP SYN scanning can also immediately detect 3 of the 4 important types of port status: open, closed, and filtered. When a SYN is sent to an open port and unfiltered port, a SYN/ACK will be generated. This technique allows an attacker to scan through stateful firewalls due to the common configuration that TCP SYN segments for a new connection will be allowed for almost any port. When a SYN packet is sent to a closed port a RST is generated, indicating the port is closed. When SYN scanning to a particular port generates no response, or when the request triggers ICMP Type 3 unreachable errors, the port is filtered. A TCP Connect scan has the following characteristics: 1. Speed: TCP SYN scanning is fast compared to other types of scans. 2. Stealth: TCP SYN scanning is stealthy and SYN scan detection is fraught with false positives. 3. Open Port: Detects that a port is open via a successful SYN/ACK to the SYN. 4. Closed Port: Detects that a port is closed via a successful RST to the SYN 5. Filtered Port: No response, or ICMP messages, indicates the presence of a filter. 6. Unfiltered Port: Cannot distinguish between a state-fully filtered port and an unfiltered port. SYN scanning is fast and provides the attacker with a wealth of information. The primary drawback is that SYN scanning requires the ability to access "raw sockets" in order to create the packets. As a result, it is not possible to perform a SYN scan from some systems (Windows XP SP 2). On other systems (BSD, Linux) administrative privileges are required in order to write to the raw socket.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>This scan type is not possible with some operating systems (Windows XP SP 2). On Linux and Unix systems it requires root privileges to use raw sockets.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="474" name="Signature Spoofing by Key Theft">
		<capec:Attack_Pattern_Description>An attacker obtains an authoritative or reputable signer's private signature key by theft and then uses this key to forge signatures from the original signer to mislead a victim into performing actions that benefit the attacker.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An authoritative or reputable signer is storing their private signature key with insufficient protection.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Spoofing
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence> empty 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="473" name="Signature Spoof">
		<capec:Attack_Pattern_Description>An attacker generates a message or datablock that causes the recipient to believe that the message or datablock was generated and cryptographically signed by an authoritative or reputable source, misleading a victim or victim operating system into performing malicious actions.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The victim or victim system is dependent upon a cryptographic signature-based verification system for validation of one or more security events or actions.
			The validation can be bypassed via an attacker-provided signature that makes it appear that the legitimate authoritative or reputable source provided the signature.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Analysis
			API Abuse
			Brute Force
			Spoofing
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Access_Control Authentication 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="476" name="Signature Spoofing by Misrepresentation">
		<capec:Attack_Pattern_Description>An attacker exploits a weakness in the parsing or display code of the recipient software to generate a data blob containing a supposedly valid signature, but the signer's identity is falsely represented, which can lead to the attacker manipulating the recipient software or its victim user to perform compromising actions.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Recipient is using signature verification software that does not clearly indicate potential homographs in the signer identity.
			Recipient is using signature verification software that contains a parsing vulnerability, or allows control characters in the signer identity field, such that a signature is mistakenly displayed as valid and from a known or authoritative signer.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Spoofing
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence> empty 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="475" name="Signature Spoofing by Improper Validation">
		<capec:Attack_Pattern_Description>An attacker exploits a cryptographic weakness in the signature verification algorithm implementation to generate a valid signature without knowing the key.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Recipient is using a weak cryptographic signature verification algorithm or a weak implementation of a cryptographic signature verification algorithm, or the configuration of the recipient's application accepts the use of keys generated using cryptographically weak signature verification algorithms.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Analysis
			API Abuse
			Brute Force
			Spoofing
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence> empty 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="477" name="Signature Spoofing by Mixing Signed and Unsigned Content">
		<capec:Attack_Pattern_Description>An attacker exploits the underlying complexity of a data structure that allows for both signed and unsigned content, to cause unsigned data to be processed as though it were signed data.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Signer and recipient are using complex data storage structures that allow for a mix between signed and unsigned data
			Recipient is using signature verification software that does not maintain separation between signed and unsigned data once the signature has been verified.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Analysis
			API Abuse
			Spoofing
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence> empty 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="275" name="DNS Rebinding">
		<capec:Attack_Pattern_Description>An attacker serves content whose IP address is resolved by a DNS server that it controls and after initial contact by a web browser or similar client it changes the IP address to which its name resolves to an address within the target browser's organization that is not publicly accessible, thus allowing the web browser to examine this internal address on its behalf. Web browsers enforce security zones based on DNS names in order to prevent cross-zone disclosure of information. In a DNS binding attack an attacker publishes content on their own server with their own name and DNS server. The first time the target accesses the attackers' content, the attackers' name must be resolved to an IP address. The attacker's DNS server performs this resolution, providing a short Time-To-Live (TTL) in order to prevent the target from caching the value. When the target makes a subsequent request to the attackers' content the attackers' DNS server must again be queried, but this time the DNS server returns an address internal to the target's organization that would not be accessible from an outside source. Because the same name resolves to both these IP addresses, browsers will place both IP addresses in the same security zone and allow information to flow between the addresses. The attacker can then use scripts in the content the target retrieved from the attacker in the original message to exfiltrate data from the named internal addresses. This allows attackers to discover sensitive information about the internal network of an enterprise. If there is a trust relationship between the computer with the targeted browser and the internal machine the attacker identifies, additional attacks are possible. This attack differs from pharming attacks in that the attacker is the legitimate owner of the malicious DNS server and so does not need to compromise behavior of external DNS services.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target browser must access content server from the attacker controlled DNS name. Web advertisements are often used for this purpose. The target browser must honor the TTL value returned by the attacker and re-resolve the attackers' DNS name after initial contact.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="109" name="Object Relational Mapping Injection">
		<capec:Attack_Pattern_Description>An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject his or her own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An application uses data access layer generated by an ORM tool or framework
			An application uses user supplied data in queries executed against the database
			The separation between data plane and control plane is not ensured, through either developer error or an underlying weakness in the data access layer code generation framework
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Analysis
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart DoS: instability 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="108" name="Command Line Execution through SQL Injection">
		<capec:Attack_Pattern_Description>An attacker uses standard SQL injection methods to inject data into the command line for execution. This could be done directly through misuse of directives such as MSSQL_xp_cmdshell or indirectly through injection of data into the database that would be interpreted as shell commands. Sometime later, an unscrupulous backend application (or could be part of the functionality of the same application) fetches the injected data stored in the database and uses this data as command line arguments without performing proper validation. The malicious data escapes that data plane by spawning new commands to be executed on the host.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The application does not properly validate data before storing in the database
			Backend application implicitly trusts the data stored in the database
			Malicious data is used on the backend as a command line argument
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory Read application data 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart DoS: instability 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="107" name="Cross Site Tracing">
		<capec:Attack_Pattern_Description>Cross Site Tracing (XST) enables an attacker to steal the victim's session cookie and possibly other authentication credentials transmitted in the header of the HTTP request when the victim's browser communicates to destination system's web server. The attacker first gets a malicious script to run in the victim's browser that induces the browser to initiate an HTTP TRACE request to the web server. If the destination web server allows HTTP TRACE requests, it will proceed to return a response to the victim's web browser that contains the original HTTP request in its body. The function of HTTP TRACE, as defined by the HTTP specification, is to echo the request that the web server receives from the client back to the client. Since the HTTP header of the original request had the victim's session cookie in it, that session cookie can now be picked off the HTTP TRACE response and sent to the attackers' malicious site. XST becomes relevant when direct access to the session cookie via the "document.cookie" object is disabled with the use of httpOnly attribute which ensures that the cookie can be transmitted in HTTP requests but cannot be accessed in other ways. Using SSL does not protect against XST. If the system with which the victim is interacting is susceptible to XSS, an attacker can exploit that weakness directly to get his or her malicious script to issue an HTTP TRACE request to the destination system's web server. In the absence of an XSS weakness on the site with which the victim is interacting, an attacker can get the script to come from the site that he controls and get it to execute in the victim's browser (if he can trick the victim's into visiting his malicious website or clicking on the link that he supplies). However, in that case, due to the same origin policy protection mechanism in the browser, the attackers' malicious script cannot directly issue an HTTP TRACE request to the destination system's web server because the malicious script did not originate at that domain. An attacker will then need to find a way to exploit another weakness that would enable him or her to get around the same origin policy protection.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>HTTP TRACE is enabled on the web server
			The destination system is susceptible to XSS or an attacker can leverage some other weakness to bypass the same origin policy
			Scripting is enabled in the client's browser
			HTTP is used as the communication protocol between the server and the client
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read memory Read application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="106" name="Cross Site Scripting through Log Files">
		<capec:Attack_Pattern_Description>An attacker may leverage a system weakness where logs are susceptible to log injection to insert scripts into the system's logs. If these logs are later viewed by an administrator through a thin administrative interface and the log data is not properly HTML encoded before being written to the page, the attackers' scripts stored in the log will be executed in the administrative interface with potentially serious consequences. This attack pattern is really a combination of two other attack patterns: log injection and stored cross site scripting.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The system uses a web based interface
			The system does not cleanse / validate user supplied data before writing it to logs
			Information from logs is displayed in a web based interface
			The web based log interface does not HTML output encode the log data prior to displaying it in the administrator console.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data Read files or directories 
			Scope:  Confidentiality Authorization Access_Control 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory Modify files or directories Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="105" name="HTTP Request Splitting">
		<capec:Attack_Pattern_Description>HTTP Request Splitting (also known as HTTP Request Smuggling) is an attack pattern where an attacker attempts to insert additional HTTP requests in the body of the original (enveloping) HTTP request in such a way that the browser interprets it as one request but the web server interprets it as two. There are several ways to perform HTTP request splitting attacks. One way is to include double Content-Length headers in the request to exploit the fact that the devices parsing the request may each use a different header. Another way is to submit an HTTP request with a "Transfer Encoding: chunked" in the request header set with setRequestHeader to allow a payload in the HTTP Request that can be considered as another HTTP Request by a subsequent parsing entity. A third way is to use the "Double CR in an HTTP header" technique. There are also a few less general techniques targeting specific parsing vulnerabilities in certain web servers.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>User-manipulateable HTTP Request headers are processed by the web server
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Injection
			Analysis
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="104" name="Cross Zone Scripting">
		<capec:Attack_Pattern_Description>An attacker is able to cause a victim to load content into their web-browser that bypasses security zone controls and gain access to increased privileges to execute scripting code or other web objects such as unsigned ActiveX controls or applets. This is a privilege elevation attack targeted at zone-based web-browser security. In a zone-based model, pages belong to one of a set of zones corresponding to the level of privilege assigned to that page. Pages in an untrusted zone would have a lesser level of access to the system and/or be restricted in the types of executable content it was allowed to invoke. In a cross-zone scripting attack, a page that should be assigned to a less privileged zone is granted the privileges of a more trusted zone. This can be accomplished by exploiting bugs in the browser, exploiting incorrect configuration in the zone controls, through a cross-site scripting attack that causes the attackers' content to be treated as coming from a more trusted page, or by leveraging some piece of system functionality that is accessible from both the trusted and less trusted zone. This attack differs from "Restful Privilege Escalation" in that the latter correlates to the inadequate securing of RESTful access methods (such as HTTP DELETE) on the server, while cross-zone scripting attacks the concept of security zones as implemented by a browser.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target must be using a zone-aware browser.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data Modify files or directories Modify memory 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data Read files or directories Read memory 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="103" name="Clickjacking">
		<capec:Attack_Pattern_Description>In a clickjacking attack the victim is tricked into unknowingly initiating some action in one system while interacting with the UI from seemingly completely different system. While being logged in to some target system, the victim visits the attackers' malicious site which displays a UI that the victim wishes to interact with. In reality, the clickjacked page has a transparent layer above the visible UI with action controls that the attacker wishes the victim to execute. The victim clicks on buttons or other UI elements they see on the page which actually triggers the action controls in the transparent overlaying layer. Depending on what that action control is, the attacker may have just tricked the victim into executing some potentially privileged (and most certainly undesired) functionality in the target system to which the victim is authenticated. The basic problem here is that there is a dichotomy between what the victim thinks he's clicking on versus what he or she is actually clicking on.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The victim is communicating with the target application via a web based UI and not a thick client
			The victim's browser security policies allow at least one of the following JavaScript, Flash, iFrames, ActiveX, or CSS.
			The victim uses a modern browser that supports UI elements like clickable buttons (i.e. not using an old text only browser)
			The victim has an active session with the target system.
			The target system's interaction window is open in the victim's browser and supports the ability for initiating sensitive actions on behalf of the user in the target system
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Spoofing
			Social Engineering
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data Modify files or directories Modify memory 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data Read memory Read files or directories 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart DoS: instability 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="99" name="XML Parser Attack">
		<capec:Attack_Pattern_Description>Applications often need to transform data in and out of the XML format by using an XML parser. It may be possible for an attacker to inject data that may have an adverse effect on the XML parser when it is being processed. These adverse effects may include the parser crashing, consuming too much of a resource, executing too slowly, executing code supplied by an attacker, allowing usage of unintended system functionality, etc. An attacker's goal is to leverage parser failure to his or her advantage. In some cases it may be possible to jump from the data plane to the control plane via bad data being passed to an XML parser. [R.99.1]</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An application uses an XML parser to perform transformation on user-controllable data.
			An application does not perform sufficient validation to ensure that user-controllable data is safe for an XML parser.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (memory) 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="102" name="Session Sidejacking">
		<capec:Attack_Pattern_Description>Session sidejacking takes advantage of an unencrypted communication channel between a victim and target system. The attacker sniffs traffic on a network looking for session tokens in unencrypted traffic. Once a session token is captured, the attacker performs malicious actions by using the stolen token with the targeted application to impersonate the victim. This attack is a specific method of session hijacking, which is exploiting a valid session token to gain unauthorized access to a target system or information. Other methods to perform a session hijacking are session fixation, cross-site scripting, or compromising a user or server machine and stealing the session token.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An attacker and the victim are both using the same WiFi network.
			The victim has an active session with a target system.
			The victim is not using a secure channel to communicate with the target system (e.g. SSL, VPN, etc.)
			The victim initiated communication with a target system that requires transfer of the session token or the target application uses AJAX and thereby periodically "rings home" asynchronously using the session token
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Time and State
			Analysis
			Spoofing
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart DoS: instability 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="101" name="Server Side Include (SSI) Injection">
		<capec:Attack_Pattern_Description>An attacker can use Server Side Include (SSI) Injection to send code to a web application that then gets executed by the web server. Doing so enables the attacker to achieve similar results to Cross Site Scripting, viz., arbitrary code execution and information disclosure, albeit on a more limited scale, since the SSI directives are nowhere near as powerful as a full-fledged scripting language. Nonetheless, the attacker can conveniently gain access to sensitive files, such as password files, and execute shell commands.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>A web server that supports server side includes and has them enabled
			User controllable input that can carry include directives to the web server
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data Read files or directories 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="100" name="Overflow Buffers">
		<capec:Attack_Pattern_Description>Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an attacker. As a consequence, an attacker is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the attackers' choice.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Targeted software performs buffer operations.
			Targeted software inadequately performs bounds-checking on buffer operations.
			Attacker has the capability to influence the input to buffer operations.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Analysis
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="98" name="Phishing">
		<capec:Attack_Pattern_Description>Phishing is a social engineering technique where an attacker masquerades as a legitimate entity with which the victim might do business in order to prompt the user to reveal some confidential information (very frequently authentication credentials) that can later be used by an attacker. Phishing is essentially a form of information gathering or "fishing" for information.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An attacker needs to have a way to initiate contact with the victim. Typically that will happen through e-mail.
			An attacker needs to correctly guess the entity with which the victim does business and impersonate it. Most of the time phishers just use the most popular banks/services and send out their "hooks" to many potential victims.
			An attacker needs to have a sufficiently compelling call to action to prompt the user to take action.
			The replicated website needs to look extremely similar to the original website and the URL used to get to that website needs to look like the real URL of the said business entity.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Social Engineering
			Spoofing
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="97" name="Cryptanalysis">
		<capec:Attack_Pattern_Description>Cryptanalysis is a process of finding weaknesses in cryptographic algorithms and using these weaknesses to decipher the ciphertext without knowing the secret key (instance deduction). Sometimes the weakness is not in the cryptographic algorithm itself, but rather in how it is applied that makes cryptanalysis successful. An attacker may have other goals as well, such as: 1. Total Break - Finding the secret key 2. Global Deduction - Finding a functionally equivalent algorithm for encryption and decryption that does not require knowledge of the secret key. 3. Information Deduction - Gaining some information about plaintexts or ciphertexts that was not previously known 4. Distinguishing Algorithm - The attacker has the ability to distinguish the output of the encryption (ciphertext) from a random permutation of bits The goal of the attacker performing cryptanalysis will depend on the specific needs of the attacker in a given attack context. In most cases, if cryptanalysis is successful at all, an attacker will not be able to go past being able to deduce some information about the plaintext (goal 3). However, that may be sufficient for an attacker, depending on the context.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target software utilizes some sort of cryptographic algorithm.
			An underlying weaknesses exists either in the cryptographic algorithm used or in the way that it was applied to a particular chunk of plaintext.
			The encryption algorithm is known to the attacker.
			An attacker has access to the ciphertext.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Brute Force
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="96" name="Block Access to Libraries">
		<capec:Attack_Pattern_Description>An application typically makes calls to functions that are a part of libraries external to the application. These libraries may be part of the operating system or they may be third party libraries. It is possible that the application does not handle situations properly where access to these libraries has been blocked. Depending on the error handling within the application, blocked access to libraries may leave the system in an insecure state that could be leveraged by an attacker.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An application requires access to external libraries.
			An attacker has the privileges to block application access to external libraries.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>API Abuse
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  Alter execution logic 
			Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="95" name="WSDL Scanning">
		<capec:Attack_Pattern_Description>This attack targets the WSDL interface made available by a web service. The attacker may scan the WSDL interface to reveal sensitive information about invocation patterns, underlying technology implementations and associated vulnerabilities. This type of probing is carried out to perform more serious attacks (e.g. parameter tampering, malicious content injection, command injection, etc.). WSDL files provide detailed information about the services ports and bindings available to consumers. For instance, the attacker can submit special characters or malicious content to the Web service and can cause a denial of service condition or illegal access to database records. In addition, the attacker may try to guess other private methods by using the information provided in the WSDL files.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>A client program connecting to a web service can read the WSDL to determine what functions are available on the server.
			The target host exposes vulnerable functions within its WSDL interface.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="94" name="Man in the Middle Attack">
		<capec:Attack_Pattern_Description>This type of attack targets the communication between two components (typically client and server). The attacker places himself in the communication channel between the two components. Whenever one component attempts to communicate with the other (data flow, authentication challenges, etc.), the data first goes to the attacker, who has the opportunity to observe or alter it, and it is then passed on to the other component as if it was never intercepted. This interposition is transparent leaving the two compromised components unaware of the potential corruption or leakage of their communications. The potential for Man-in-the-Middle attacks yields an implicit lack of trust in communication or identify between two components.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>There are two components communicating with each other.
			An attacker is able to identify the nature and mechanism of communication between the two target components.
			An attacker can eavesdrop on the communication between the target components.
			Strong mutual authentication is not used between the two target components yielding opportunity for attacker interposition.
			The communication occurs in clear (not encrypted) or with insufficient and spoofable encryption.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Spoofing
			Analysis
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="93" name="Log Injection-Tampering-Forging">
		<capec:Attack_Pattern_Description>This attack targets the log files of the target host. The attacker injects, manipulates or forges malicious log entries in the log file, allowing him to mislead a log audit, cover traces of attack, or perform other malicious actions. The target host is not properly controlling log access. As a result tainted data is resulting in the log files leading to a failure in accountability, non-repudiation and incident forensics capability.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The target host is logging the action and data of the user.
			The target host insufficiently protects access to the logs or logging mechanisms.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Modification of Resources
			Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="92" name="Forced Integer Overflow">
		<capec:Attack_Pattern_Description>This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker can manipulate the value of an integer variable utilized by the target host.
			The target host does not do proper range checking on the variable before utilizing it.
			When the integer variable is incremented or decremented to an out of range value, it gets a very different value (e.g. very small or negative number)
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Modification of Resources
			Injection
			API Abuse
			Analysis
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Availability 
			Impact(Motivation):  DoS: crash / exit / restart 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="91" name="XSS in IMG Tags">
		<capec:Attack_Pattern_Description>Image tags are an often overlooked, but convenient, means for a Cross Site Scripting attack. The attacker can inject script contents into an image (IMG) tag in order to steal information from a victim's browser and execute malicious scripts.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Application permitting the inclusion or use of IMG tags
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="90" name="Reflection Attack in Authentication Protocol">
		<capec:Attack_Pattern_Description>An attacker can abuse an authentication protocol susceptible to reflection attack in order to defeat it. Doing so allows the attacker illegitimate access to the target system, without possessing the requisite credentials. Reflection attacks are of great concern to authentication protocols that rely on a challenge-handshake or similar mechanism. An attacker can impersonate a legitimate user and can gain illegitimate access to the system by successfully mounting a reflection attack during authentication.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker must have direct access to the target server in order to successfully mount a reflection attack. An intermediate entity, such as a router or proxy, that handles these exchanges on behalf of the attacker inhibits the attackers' ability to attack the authentication protocol.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Protocol Manipulation
			Spoofing
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity Bypass protection mechanism 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="294" name="ICMP Address Mask Request">
		<capec:Attack_Pattern_Description>An attacker sends an ICMP Type 17 Address Mask Request to gather information about a target's networking configuration. ICMP Address Mask Requests are defined by RFC-950, "Internet Standard Subnetting Procedure." An Address Mask Request is an ICMP type 17 message that triggers a remote system to respond with a list of its related subnets, as well as its default gateway and broadcast address via an ICMP type 18 Address Mask Reply datagram. Gathering this type of information helps an attacker plan router-based attacks as well as denial-of-service attacks against the broadcast address. Many modern operating systems will not respond to ICMP type 17 messages for security reasons. Determining whether a system or router will respond to an ICMP Address Mask Request helps the attacker determine operating system or firmware version. Additionally, because these types of messages are rare they are easily spotted by intrusion detection systems. Many ICMP scanning tools support IP spoofing to help conceal the origin of the actual request among a storm of similar ICMP messages. It is a common practice for border firewalls and gateways to be configured to block ingress ICMP type 17 and egress ICMP type 18 messages.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send an ICMP type 17 query (Address Mask Request) to a remote target and receive an ICMP type 18 message (ICMP Address Mask Reply) in response. Generally, modern operating systems will ignore ICMP type 17 messages, however, routers will commonly respond to this request.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="293" name="Traceroute Route Enumeration">
		<capec:Attack_Pattern_Description>An attacker uses a traceroute utility to map out the route which data flows through the network in route to a target destination. Tracerouting can allow an attacker to construct a working topology of systems and routers by listing the systems through which data passes through on their way to the targeted machine. This attack can return varied results depending upon the type of traceroute that is performed. Traceroute works by sending packets to a target while incrementing the Time-to-Live field in the packet header. As the packet traverses each hop along its way to the destination, its TTL expires generating an ICMP diagnostic message that identifies where the packet expired. Traditional techniques for tracerouting involved the use of ICMP and UDP. As more firewalls began to filter ingress ICMP, methods of traceroute using TCP were developed</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>A network capable of routing the attackers' packets to the destination network.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="296" name="ICMP Information Request">
		<capec:Attack_Pattern_Description>An attacker sends an ICMP Information Request to a host to determine if it will respond to this deprecated mechanism. ICMP Information Requests are a deprecated message type that no has any use. Information Requests were originally used for diskless machines to automatically obtain their network configuration, but this message type has been superseded by more robust protocol implementations like DHCP.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send an ICMP Type 15 Information Request and receive an ICMP Type 16 Information Reply in response.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="295" name="ICMP Timestamp Request">
		<capec:Attack_Pattern_Description>An attacker sends an ICMP type 13 Timestamp Request to determine the time as recorded by a remote target. Timestamp Replies, ICMP Type 14, usually return a value in Greenwich Mean Time. An attacker can attempt to use an ICMP Timestamp requests to 'ping' a remote system to see if is alive. An attacker may be able to use the timestamp returned from the target to attack time-based security algorithms, such as random number generators, or time-based authentication mechanisms. Additionally, because these types of messages are rare they are easily spotted by intrusion detection systems. Many ICMP scanning tools support IP spoofing to help conceal the origin of the actual request among a storm of similar ICMP messages. It is a common practice for border firewalls and gateways to be configured to block ingress ICMP type 13 and egress ICMP type 14 messages.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send an ICMP type 13 query (Timestamp Request) to a remote target and receive an ICMP type 14 message (Timestamp Reply) in response.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="290" name="Enumerate Mail Exchange (MX) Records">
		<capec:Attack_Pattern_Description>An attacker enumerates the MX records for a given via a DNS query. This type of information gathering returns the names of mail servers on the network. Mail servers are often not exposed to the Internet but are located within the DMZ of a network protected by a Firewall. A side effect of this configuration is that enumerating the MX records for an organization my reveal the IP address of the firewall or possibly other internal systems. Attackers often resort to MX record enumeration when a DNS Zone Transfer is not possible.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Access to a DNS server that will return the MX records for a network.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="292" name="Host Discovery">
		<capec:Attack_Pattern_Description>An attacker sends a probe to an IP address to determine if the host is alive. Host discovery is one of the earliest phases of network reconnaissance. An attacker usually starts with a range of IP addresses belonging to a target network and uses various methods to determine if a host is present at that IP address. Host discovery is usually referred to as 'Ping' scanning using a sonar analogy. The goal of the attacker is to send a packet through to the IP address and solicit a response from the host. As such, a 'ping' can be virtually any crafted packet whatsoever, provided the attacker can identify a functional host based on its response. An attack of this nature is usually carried out with a 'ping sweep' where a particular kind of ping is sent to a range of IP addresses.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>A network capable of routing the attackers' packets to the destination network.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="291" name="DNS Zone Transfers">
		<capec:Attack_Pattern_Description>An attacker exploits a DNS misconfiguration that permits a ZONE transfer. Some external DNS servers will return a list of IP address and valid hostnames. Under certain conditions, it may even be possible to obtain Zone data about the organization's internal network. When successful the attacker learns valuable information about the topology of the target organization, including information about particular servers, their role within the IT structure, and possibly information about the operating systems running upon the network. This is configuration dependent behavior so it may also be required to search out multiple DNS servers while attempting to find one with ZONE transfers allowed.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Access to a DNS server that allows Zone transfers.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="297" name="TCP ACK Ping">
		<capec:Attack_Pattern_Description>An attacker sends a TCP segment with the ACK flag set to a remote host for the purpose of determining if the host is alive. This is one of several TCP 'ping' types. The RFC 793 expected behavior for a service is to respond with a RST 'reset' packet to any unsolicited ACK segment that is not part of an existing connection. So by sending an ACK segment to a port, an attacker identify that the host is alive by looking for a RST packet. Typically a remote server will respond with a RST regardless of whether a port is open or closed. In either case, the attacker can determine that the host is alive. TCP ACK pings cannot discover the state of a remote port because the behavior is the same in either case. TCP ACK pings are most likely to fail in cases where a stateful firewall is present. The firewall will look up the ACK packet in its state-table and discard the segment because it does not correspond to any active connection. A TCP ACK Ping has the following characteristics: 1. Host Discovery: Can be used to discover if a host is alive via RST response packets sent from the host. 2. Effective Against: Stateless Firewalls due to a typical lack of rules that reject unsolicited ACK packets. 3. Weak Against: Stateful Firewalls due to the ability to reject a packet not part of an existing connection. 4. Port State: Unable to determine if a port is open or closed. The tool nmap will send TCP ACK pings when the command line "-PA" switch is used. Sending an ACK ping requires the ability to access "raw sockets" in order to create the packets with direct access to the packet header.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send an ACK packet to a remote host and identify the response. Creating the ACK packet without building a full connection requires the use of raw sockets. As a result, it is not possible to send a TCP ACK ping from some systems (Windows XP SP 2) without the use of third-party packet drivers like Winpcap. On other systems (BSD, Linux) administrative privileges are required in order to write to the raw socket.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="298" name="UDP Ping">
		<capec:Attack_Pattern_Description>An attacker sends a UDP datagram to the remote host to determine if the host is alive. If a UDP datagram is sent to an open UDP port there is very often no response, so a typical strategy for using a UDP ping is to send the datagram to a random high port on the target. The goal is to solicit an ICMP port unreachable message from the target, indicating that the host is alive. UDP pings are useful because some firewalls are not configured to block UDP datagrams sent to strange or typically unused ' ports, like ports in the 65K range. Additionally, while some firewalls may filter incoming ICMP, weaknesses in firewall rule-sets may allow certain types of ICMP (host unreachable, port unreachable) which are useful for UDP ping attempts. A UDP Ping has the following characteristics: 1. Host Discovery: Can be used to discover if a host is alive via ICMP Port Unreachable Messages. 2. Effective Against: Firewalls that allow some incoming UDP which are not configured to block egress ICMP messages. 3. Weak Against: Firewalls properly configured to block UDP datagrams that are also block egress ICMP messages. 4. Port State: Able to determine if a port is closed via ICMP Port Unreachable Messages.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send a UDP datagram to a remote host and receive a response.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="299" name="TCP SYN Ping">
		<capec:Attack_Pattern_Description>An attacker uses a TCP SYN packets as a means of purpose of host discovery. Typical RFC 793 behavior specifies that when a TCP port is open, a host must respond to an incoming SYN "synchronize" packet by completing stage two of the 'three-way handshake' by sending an SYN/ACK in response. When a port is closed, RFC 793 behavior is to respond with a RST "reset" packet. This behavior can be used to 'ping' a target to see if it is alive by sending a TCP SYN packet to a port and then looking for a RST or an ACK packet in response. Due to the different responses from open and closed ports, SYN packets can be used to determine the remote state of the port. A TCP SYN ping is also useful for discovering alive hosts protected by a stateful firewall. In cases where a specific firewall rule does not block access to a port, a SYN packet can pass through the firewall to the host and solicit a response from either an open or closed port. When a stateful firewall is present SYN pings are preferable to ACK pings, because a stateful firewall will typically drop all unsolicited ACK packets because they are not part of an existing or new connection. TCP SYN pings often fail when a stateless ACL or firewall is configured to blanket-filter incoming packets to a port. The firewall device will discard any SYN packets to a blocked port. An attacker will often alternate between SYN and ACK pings to discover if a host is alive. A TCP SYN ping has the following characteristics: 1. Host Discovery: Can be used to discover if a host is alive via ACK or RST packets. 2. Effective Against: Stateful Firewalls that allow incoming new connections to target ports. 3. Weak Against: Stateless firewalls that blanket-filter incoming SYN 4. Port State: Able to determine port state via SYN/ACK or RST response.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The ability to send a TCP SYN packet to a remote target. Depending upon the operating system, the ability to craft SYN packets may require elevated privileges.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>empty
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism Hide activities 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="88" name="OS Command Injection">
		<capec:Attack_Pattern_Description>In this type of an attack, an adversary injects operating system commands into existing application functions. An application that uses untrusted input to build command strings is vulnerable. An adversary can leverage OS command injection in an application to elevate privileges, execute arbitrary commands and compromise the underlying operating system.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>User controllable input used as part of commands to the underlying operating system.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity Bypass protection mechanism 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="89" name="Pharming">
		<capec:Attack_Pattern_Description>A pharming attack occurs when the victim is fooled into entering sensitive data into supposedly trusted locations, such as an online bank site or a trading platform. An attacker can impersonate these supposedly trusted sites and have the victim be directed to his site rather than the originally intended one. Pharming does not require script injection or clicking on malicious links for the attack to succeed.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Vulnerable DNS software or improperly protected hosts file or router that can be poisoned
			A website that handles sensitive information but does not use a secure connection and a certificate that is valid is also prone to pharming
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Spoofing
			Analysis
			Modification of Resources
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="244" name="Cross-Site Scripting via Encoded URI Schemes">
		<capec:Attack_Pattern_Description>An attack of this type exploits the ability of most browsers to interpret "data", "javascript" or other URI schemes as client-side executable content placeholders. This attack consists of passing a malicious URI in an anchor tag HREF attribute or any other similar attributes in other HTML tags. Such malicious URI contains, for example, a base64 encoded HTML content with an embedded cross-site scripting payload. The attack is executed when the browser interprets the malicious content i.e., for example, when the victim clicks on the malicious link.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>Target client software must allow scripting such as JavaScript and allows executable content delivered using a data URI scheme.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="230" name="XML Nested Payloads">
		<capec:Attack_Pattern_Description>Applications often need to transform data in and out of the XML format by using an XML parser. It may be possible for an attacker to inject data that may have an adverse effect on the XML parser when it is being processed. By nesting XML data and causing this data to be continuously self-referential, an attacker can cause the XML parser to consume more resources while processing, causing excessive memory consumption and CPU utilization. An attacker's goal is to leverage parser failure to his or her advantage. In most cases this type of an attack will result in a denial of service due to an application becoming unstable, freezing, or crash. However it may be possible to cause a crash resulting in arbitrary code execution, leading to a jump from the data plane to the control plane [R.230.1].</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An application uses an XML parser to perform transformation on user-controllable data.
			An application does not perform sufficient validation to ensure that user-controllable data is safe for an XML parser.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (memory) 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="231" name="XML Oversized Payloads">
		<capec:Attack_Pattern_Description>Applications often need to transform data in and out of the XML format by using an XML parser. It may be possible for an attacker to inject data that may have an adverse effect on the XML parser when it is being processed. By supplying oversized payloads in input vectors that will be processed by the XML parser, an attacker can cause the XML parser to consume more resources while processing, causing excessive memory consumption and CPU utilization, and potentially cause execution of arbitrary code. An attacker's goal is to leverage parser failure to his or her advantage. In many cases this type of an attack will result in a denial of service due to an application becoming unstable, freezing, or crash. However it is possible to cause a crash resulting in arbitrary code execution, leading to a jump from the data plane to the control plane [R.231.1].</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>An application uses an XML parser to perform transformation on user-controllable data.
			An application does not perform sufficient validation to ensure that user-controllable data is safe for an XML parser.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Availability 
			Impact(Motivation):  DoS: resource consumption (memory) 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="236" name="Catching exception throw/signal from privileged block">
		<capec:Attack_Pattern_Description>Attackers can sometimes hijack a privileged thread from the underlying system through synchronous (calling a privileged function that returns incorrectly) or asynchronous (callbacks, signal handlers, and similar) means. Having done so, the Attacker may not only likely access functionality the system's designer didn't intend for them, but they may also go undetected or deny other users essential service in a catastrophic (or insidiously subtle) way.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The application in question employs a threaded model of execution with the threads operating at, or having the ability to switch to, a higher privilege level than normal users
			In order to feasibly execute this class of attacks, the attacker must have the ability to hijack a privileged thread.
			This ability includes, but is not limited to, modifying environment variables that affect the process the thread belongs to, or providing malformed user-controllable input that causes the executing thread to fault and return to a higher privilege level or such.
			This does not preclude network-based attacks, but makes them conceptually more difficult to identify and execute.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			Modification of Resources
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality Integrity Availability 
			Impact(Motivation):  Execute unauthorized code or commands 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="237" name="Calling Signed Code From Another Language Within A Sandbox Allow This">
		<capec:Attack_Pattern_Description>The attacker may submit a malicious signed code from another language to obtain access to privileges that were not intentionally exposed by the sandbox, thus escaping the sandbox. For instance, Java code cannot perform unsafe operations, such as modifying arbitrary memory locations, due to restrictions placed on it by the Byte code Verifier and the JVM. If allowed, Java code can call directly into native C code, which may perform unsafe operations, such as call system calls and modify arbitrary memory locations on their behave. To provide isolation, Java does not grant untrusted code with unmediated access to native C code. Instead, the sandboxed code is typically allowed to call some subset of the pre-existing native code that is part of standard libraries.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>A framework-based language that supports code signing and sandbox (such as Java, .Net, JavaScript, and Flash) Deployed code that has been signed by its authoring vendor, or a partner
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Analysis
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="260" name="Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution">
		<capec:Attack_Pattern_Description>Attackers can capture new application installation code bound for an authorized client during initial distribution and can use it, as-is or through reverse-engineering, to glean sensitive information or exploit the trust relationship between the client and server.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker must be able to employ a sniffer in the path between the server and client without being detected. The targeted operating system or application must be configured to allow for end users to request new components and applications from the server.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>API Abuse
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="267" name="Leverage Alternate Encoding">
		<capec:Attack_Pattern_Description>This attack leverages the possibility to encode potentially harmful input and submit it to applications not expecting or effective at validating this encoding standard making input filtering difficult.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The application's decoder accepts and interprets encoded characters. Data canonicalization, input filtering and validating is not done properly leaving the door open to harmful characters for the target host.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
			Protocol Manipulation
			API Abuse
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Integrity 
			Impact(Motivation):  Modify application data 
			Scope:  Confidentiality 
			Impact(Motivation):  Read memory 
			Scope:  Integrity 
			Impact(Motivation):  Modify memory 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
			Scope:  Authorization 
			Impact(Motivation):  Execute unauthorized code or commands 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Access_Control Authorization 
			Impact(Motivation):  Bypass protection mechanism 
			Scope:  Availability 
			Impact(Motivation):  DoS: amplification DoS: crash / exit / restart DoS: instability DoS: resource consumption (CPU) DoS: resource consumption (memory) DoS: resource consumption (other) 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="250" name="XML Injection">
		<capec:Attack_Pattern_Description>An attacker utilizes crafted XML user-controllable input to probe, attack, and inject data into the XML database, using techniques similar to SQL injection. The user-controllable input can allow for unauthorized viewing of data, bypassing authentication or the front-end application for direct XML database access, and possibly altering database information.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>XML queries used to process user input and retrieve information stored in XML documents
			User-controllable input not properly sanitized
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>Injection
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality Access_Control Authorization 
			Impact(Motivation):  Gain privileges / assume identity 
			Scope:  Confidentiality 
			Impact(Motivation):  Read application data 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="258" name="Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update">
		<capec:Attack_Pattern_Description>Attackers can capture application code bound for an authorized client during a dynamic update and can use it, as-is or through reverse-engineering, to glean sensitive information or exploit the trust relationship between the client and server.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker must be able to employ a sniffer in the path between the server and client without being detected. The targeted application must be configured to periodically check for updates from the server.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>API Abuse
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
	<capec:Attack_Pattern id="259" name="Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching">
		<capec:Attack_Pattern_Description>Attackers can capture application code bound for an authorized client during patching and can use it, as-is or through reverse-engineering, to glean sensitive information or exploit the trust relationship between the client and server.</capec:Attack_Pattern_Description>
		<capec:Attack_Pattern_Prerequisite>The attacker must be able to employ a sniffer in the path between the server and client without being detected. The targeted application must receive some patches from the server.
		</capec:Attack_Pattern_Prerequisite>
		<capec:Attack_Pattern_Method>API Abuse
			Protocol Manipulation
		</capec:Attack_Pattern_Method>
		<capec:Attack_Pattern_Consequence>Scope:  Confidentiality 
			Impact(Motivation):  "Varies by context" 
			Scope:  Integrity 
			Impact(Motivation):  Modify files or directories 
			Scope:  Confidentiality 
			Impact(Motivation):  Read files or directories 
			Scope:  Accountability Authentication Authorization Non-Repudiation 
			Impact(Motivation):  Gain privileges / assume identity 
		</capec:Attack_Pattern_Consequence>
	</capec:Attack_Pattern>
</capec:Domain_Mappings>
